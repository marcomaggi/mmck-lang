\input texinfo.tex
@c %**start of header
@setfilename mmck-lang.info
@settitle @sc{mmck} Lang
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      Language extensions for @sc{chicken}

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    @sc{mmck} Lang

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmck-lang

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2019

@set CHICKEN_VERSION            5.1.0

@c ------------------------------------------------------------

@set PackageStem                lang

@set PackageAutoconfPrefix      MMCK_LANG
@set PackagePkgconfigModule     mmck-lang

@set GithubUrl                  @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl                @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl           @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@macro mmck{}
@sc{mmck}
@end macro

@macro chicken{}
@sc{chicken}
@end macro

@c ------------------------------------------------------------------------

@macro ChickenCoreRef{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,chicken-core}
@end macro

@macro ChickenInternalsRef{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,chicken-internals}
@end macro

@macro MMCKExceptionalConditionsRef{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,mmck-exceptional-conditions}
@end macro

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a @chicken{} language package
implementing a extensions to the language.  @chicken{} is a Scheme--to--C compiler supporting the
language features as defined in the ``Revised^5 Report on Scheme''.

The library supports @posix{} platforms.  This package has been tested with @chicken{} version
@value{CHICKEN_VERSION}.

This package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} Lesser
General Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mmck-lang: (mmck-lang).   A lang library for @chicken{}.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* debug::                       Basic debugging facilities.
* binding::                     Binding syntaxes.
* expr::                        Expression syntaxes.
* booleans::                    Boolean functions.
* lists::                       List functions.
* vectors::                     Vector functions.
* strings::                     String functions.
* parameters::                  Parameter functions and syntaxes.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


@cindex @library{mmck lang}, library
@cindex Library @library{mmck lang}


This document describes version @value{VERSION} of @value{PACKAGE}, a @chicken{} language package
implementing extensions to the language.  @chicken{} is a Scheme-to-C compiler supporting the
language features as defined in the ``Revised^5 Report on Scheme''.

This package supports @posix{} platforms.  This package depends upon the @chicken{} egg
@code{matchable}.  This package depends upon the external packages: @mmck{} Exceptional Conditions.
To run the tests distributed with the source code: this package depends upon the package @mmck{}
Checks.

The package installs the library @library{mmck lang} along with its import library.  To require the
library and import its syntactic bindings in a module we can do:

@example
(declare (unit my-module)
         (emit-import-library my-module))

(require-library (mmck lang))

(module (my-module)
    ()
  (import (scheme)
          (mmck lang))

  ...

  #| end of module |# )
@end example

@c page
@node version
@chapter Version functions


@value{PACKAGE}'s version number follows the specification of @dfn{Semantic Versioning} version 2.0
as outlined at:

@center @url{https://semver.org/}

@noindent
the following functions are available to inspect the version specification at runtime.


@defun mmck-@value{PackageStem}-package-major-version
Return a fixnum representing the package's major version number.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the major version number is the fixnum @samp{1}.
@end defun


@defun mmck-@value{PackageStem}-package-minor-version
Return a fixnum representing the package's minor version number.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the minor version number is the fixnum @samp{2}.
@end defun


@defun mmck-@value{PackageStem}-package-patch-level
Return a fixnum representing the package's patch level number.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the patch level number is the fixnum @samp{3}.
@end defun


@defun mmck-@value{PackageStem}-package-prerelease-tag
Return a string representing the package's prerelease tag.  As example, if the full semantic version
is @samp{1.2.3-devel.0+x86-64}: the prerelease tag is the string @samp{"devel.0"}.  This string may
be empty.
@end defun


@defun mmck-@value{PackageStem}-package-build-metadata
Return a string representing the package's build metadata.  As example, if the full semantic version
is @samp{1.2.3-devel.0+x86-64}: the build metadata is the string @samp{"x86-64"}.  This string may
be empty.  We need to remember that this specification segment must contain only @ascii{}
alphanumerics and hyphen @samp{[0-9A-Za-z-]}; underscores are @strong{not} allowed.
@end defun


@defun mmck-@value{PackageStem}-package-version
Return a string representing the package's version.  As example, if the full semantic version is
@samp{1.2.3-devel.0+x86-64}: the package version is the string @samp{"1.2.3-devel.0"}, without the
build metadata.
@end defun


@defun mmck-@value{PackageStem}-package-semantic-version
Return a string representing the package's semantic version.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the package version is the string
@samp{"v1.2.3-devel.0+x86-64"}, notice the leading character @samp{v}.
@end defun

@c page
@node debug
@chapter Basic debugging facilities


@defun debug-print @var{obj} @dots{}
Gather all the @var{obj} values in a list and print it the value of @code{(current-error-port)},
followed by a newline character.
@end defun

@c page
@node binding
@chapter Binding syntaxes


@menu
* binding reexports::           Reexported syntactic bindings.
* binding vars::                Defining syntactic bindings for variables.
* binding syns::                Defining syntactic bindings for syntaxes.
@end menu

@c page
@node binding reexports
@section Reexported syntactic bindings


@cindex Reexported syntactic bindings
@findex @syntax{case-lambda}, reexported syntactic binding
@findex @syntax{receive}, reexported syntactic binding


The library @library{mmck lang} reexports the following syntactic bindings from @library{chicken
base}:

@lisp
case-lambda
receive
@end lisp

@c page
@node binding vars
@section Defining syntactic bindings for variables


@menu
* binding vars define*::             The syntax @syntax{define*}.
* binding vars case-define::         The syntax @syntax{case-define}.
* binding vars case-define*::        The syntax @syntax{case-define*}.
* binding vars receive-and-return::  The syntax @syntax{receive-and-return}.
@end menu

@c page
@node binding vars define*
@subsection The syntax @syntax{define*}


@cindex @syntax{__who__}, defined by @syntax{define*}


@deffn Syntax {define*} (@qvar{who} . @qvar{formals}) @qvaro{body} @qvar{body} @dots{}
@deffnx Syntax {define*} @qvar{who} @qvar{expr}
Similar to @syntax{define}.  Inject the unhygienic syntax @syntax{__who__} whose uses expand into
@code{(quote @qvar{who})} so that its region of visibility is the defined expression.  The first
form expands into something like:

@lisp
(define @qvar{who}
  (lambda @qvar{formals})
    (let-syntax ((__who__ (syntax-rules ()
                            ((_)
                             (quote @qvar{who})))))
      @qvaro{body} @qvar{body} @dots{}))
@end lisp

@noindent
the second form expands into something like:

@lisp
(define @qvar{who}
  (let-syntax ((__who__ (syntax-rules ()
                          ((_)
                           (quote @qvar{who})))))
    @qvar{expr}))
@end lisp
@end deffn


Let's see some basic usage examples:

@lisp
(begin
  (define* (doit1 a b)
    (list __who__ a b))

  (doit1 'A 'B))
@result{} (doit1 A B)

(begin
  (define* (doit2 a b . rest)
    (list (__who__) a b rest))

  (doit2 'A 'B 'C 'D 'E))
@result{} (doit2 A B (C D E))

(begin
  (define* (doit . args)
    (list (__who__) args))

  (doit 'A 'B 'C 'D 'E))
@result{} (doit (A B C D E))

(define* it
  (list (__who__) 1 2))

it      @result{} (it 1 2)
@end lisp

Now let's see how to build and raise an exceptional--condition object, as defined by
@library{chicken condition}, with @code{location} property:

@lisp
(import (scheme)
        (mmck lang)
        (prefix (chicken condition) chicken::))

(define* (raise-it)
  (chicken::abort
   (chicken::make-property-condition 'mine 'location (__who__))))

(chicken::condition-case
    (raise-it)
  (E (mine)
     (chicken::get-condition-property E 'mine 'location))
  (() #f))
@result{} raise-it
@end lisp

Now let's see how to build and raise an exceptional--condition object, as defined by @library{mmck
exceptional-conditions}, with a @condition{who} component:

@lisp
(import (scheme)
        (mmck lang)
        (mmck exceptional-conditions))

(define* (raise-it)
  (raise
   (condition (make-error)
              (make-who-condition (__who__)))))

(guard (E ((error? E)
           (condition-who E))
          (else #f))
  (raise-it))
@result{} raise-it
@end lisp

@c page
@node binding vars case-define
@subsection The syntax @syntax{case-define}


@deffn Syntax case-define @qvar{who} (@qvar{formals} @qvaro{body} @qvar{body} @dots{}) @dots{}
Define a function accepting multiple formals specifications.  Inject the unhygienic syntax
@syntax{__who__} whose uses expand into @code{(quote @qvar{who})} so that its region of visibility
is the defined expression.  Expands into:

@lisp
(define @qvar{who}
  (case-lambda
    (@qvar{formals} @qvaro{body} @qvar{body} @dots{})
    @dots{}))
@end lisp

@noindent
where @syntax{case-lambda} is the syntax exported by @library{chicken base}.
@end deffn


Usage examples:

@lisp
(case-define doit
  (()                   0)
  ((a)                  (list 1 a))
  ((a b)                (list 2 a b))
  ((a b c . rest)       (list '* a b c rest)))

(doit)                  @result{} 0
(doit 'A)               @result{} (1 A)
(doit 'A 'B)            @result{} (2 A B)
(doit 'A 'B 'C 'D 'E)   @result{} (* A B C (D E))
@end lisp

@c page
@node binding vars case-define*
@subsection The syntax @syntax{case-define*}


@cindex @syntax{__who__}, defined by @syntax{case-define*}


@deffn Syntax case-define* @qvar{who} (@qvar{formals} @qvaro{body} @qvar{body} @dots{}) @dots{}
Define a function accepting multiple formals specifications.  Expands to:

@lisp
(define @qvar{who}
  (case-lambda
    (@qvar{formals}
     (let-syntax ((__who__ (syntax-rules ()
                             ((_)
                              (quote @qvar{who})))))
       @qvaro{body} @qvar{body} @dots{}))
    @dots{}))
@end lisp

@noindent
where @syntax{case-lambda} is the syntax exported by @library{chicken base}.
@end deffn


Usage examples:

@lisp
(case-define* doit
  (()                   (list (__who__) 0))
  ((a)                  (list (__who__) 1 a))
  ((a b)                (list (__who__) 2 a b))
  ((a b c . rest)       (list (__who__) '* a b c rest)))

(doit)                  @result{} (doit 0)
(doit 'A)               @result{} (doit 1 A)
(doit 'A 'B)            @result{} (doit 2 A B)
(doit 'A 'B 'C 'D 'E)   @result{} (doit * A B C (D E))
@end lisp

@c page
@node binding vars receive-and-return
@subsection The syntax @syntax{receive-and-return}


@deffn Syntax receive-and-return @qvar{formals} @qvar{expr} @qvaro{body} @qvar{body} @dots{}
Evaluate @qvar{expr} and bind its return values to @qvar{formals}, as if @syntax{let-values} was
used; then, in the region of visibility of the formals, evaluate the @qvar{body} expressions.
Finally, return the values bound to the formals.
@end deffn


Usage examples:

@lisp
(receive-and-return (a)
    (list 1 2)
  (pretty-print a))
@result{} (1 2)
@print{} (1 2)

(receive-and-return (a b)
    (values 1 2)
  (pretty-print a))
@result{} 1 2
@print{} 1

(receive-and-return ()
    (values)
  (pretty-print 3))
@result{} #<unspecified>
@print{} 3
@end lisp

@c page
@node binding syns
@section Defining syntactic bindings for syntaxes


@menu
* binding syns define-syntax-rule::         The syntax @syntax{define-syntax-rule}.
* binding syns define-auxiliary-syntaxes::  The syntax @syntax{define-auxiliary-syntaxes}.
* binding syns auxiliary::                  Auxiliary syntaxes.
@end menu

@c page
@node binding syns define-syntax-rule
@subsection The syntax @syntax{define-syntax-rule}


@deffn Syntax define-syntax-rule (@qvar{name} . @qvar{formals}) @qvaro{expr} @qvar{expr} @dots{}
Define a macro with a single @syntax{syntax-rules} rule.  Expands to:

@lisp
(define-syntax @qvar{name}
  (syntax-rules ()
    ((_ . @qvar{formals})
     (begin @qvaro{expr} @qvar{expr} @dots{}))))
@end lisp
@end deffn


Usage examples:

@lisp
(internal-body
  (define-syntax-rule (doit a b)
    (list a b))

  (doit 1 2))
@result{} (1 2)

(internal-body
  (define-syntax-rule (doit)
    (list 1 2))

  (doit))
@result{} (1 2)

(internal-body
  (define-syntax-rule (doit ?a ?b . ?rest)
    (vector '?a '?b '?rest))

  (doit 1 2 3 4))
@result{} #(1 2 (3 4))
@end lisp

@c page
@node binding syns define-auxiliary-syntaxes
@subsection The syntax @syntax{define-auxiliary-syntaxes}


@deffn Syntax define-auxiliary-syntaxes @qvaro{name} @qvar{name} @dots{}
For each of the @qvar{name} define a syntax like:

@lisp
(define-syntax @qvar{name} (syntax-rules ()))
@end lisp

This is useful to define auxiliary syntaxes like the @syntax{else} used by the standard
@syntax{cond}.
@end deffn


Let's see how to use it with @syntax{syntax-rules}:

@lisp
(define-auxiliary-syntaxes ciao)

(define-syntax doit
  (syntax-rules (ciao)
    ((_ ciao)
     #t)
    ((_ ?thing)
     #f)))

(doit ciao)     @result{} #t
(doit hello)    @result{} #f
@end lisp

@noindent
now with @func{er-macro-transformer} and @func{match} from the @library{matchable} egg:

@lisp
(import-for-syntax (scheme)
                   (only (chicken syntax)
                         er-macro-transformer)
                   (only (matchable)
                         match))

(define-auxiliary-syntaxes ciao)

(define-syntax doit
  (er-macro-transformer
    (lambda (input-form.stx rename compare)
      (define %ciao (rename 'ciao))
      (define (ciao? obj)
        (compare %ciao obj))
      (match input-form.stx
        ((_ (? ciao?))
         #t)
        (_
         #f)))))

(doit ciao)     @result{} #t
(doit hello)    @result{} #f
@end lisp

@noindent
now with @func{ir-macro-transformer} and @func{match} from the @library{matchable} egg:

@lisp
(import-for-syntax (scheme)
                   (only (chicken syntax)
                         er-macro-transformer)
                   (only (matchable)
                         match))

(define-auxiliary-syntaxes ciao)

(define-syntax doit
  (ir-macro-transformer
    (lambda (input-form.stx inject compare)
      (define %ciao (inject 'ciao))
      (define (ciao? obj)
        (compare %ciao obj))
      (match input-form.stx
        ((_ (? ciao?))
         #t)
        (_
         #f)))))

(doit ciao)     @result{} #t
(doit hello)    @result{} #f
@end lisp

@c page
@node binding syns auxiliary
@subsection Auxiliary syntaxes


@deffn {Auxiliary Syntax} __who__
Defined in the expression/body of syntaxes like @syntax{define*}, @syntax{case-define*},
@syntax{named-lambda}.  It expands to the quoted name of the object being defined.

We can use the syntax @syntax{__who__} as value for the condition property @code{location}
(@ChickenCoreRef{condition srfi-12 condition, Condition objects}), or as value for the
@condition{who} condition object (@MMCKExceptionalConditionsRef{conditions types r6rs, Predefined
condition types compatible with @rnrs{6}}).
@end deffn

@c page
@node expr
@chapter Expression syntaxes


@menu
* expr named-lambda::           The syntax @syntax{named-lambda}.
* expr misc::                   Miscellaneous expression syntaxes.
* expr reexports::              Reexported syntactic bindings.
@end menu

@c page
@node expr named-lambda
@section The syntax @syntax{named-lambda}


@deffn Syntax named-lambda @qvar{who} @qvar{formals} @qvaro{body} @qvar{body} @dots{}
Similar to @syntax{lambda}.  Inject the unhygienic syntax @syntax{__who__} whose uses expand into
@code{(quote @qvar{who})} so that its region of visibility is the function body.  Expand into
something like:

@lisp
(lambda @qvar{formals}
  (let-syntax ((__who__ (syntax-rules ()
                          ((_)
                           (quote @qvar{who})))))
    @qvaro{body} @qvar{body} @dots{}))
@end lisp

We can use the variable @code{__who__} as value for the condition property @code{location}, or as
value for the @condition{who} condition object.
@end deffn


Usage examples:

@lisp
(define func
  (named-lambda the-func (a b)
    (list (__who__) a b)))

(func 1 2)      @result{} (the-func 1 2)
@end lisp

@c page
@node expr misc
@section Miscellaneous expression syntaxes


@deffn Syntax alist-var-cons! @qvar{alist-var} @qvar{key} @qvar{val}
Push a new entry into an association list.  Expand into:

@lisp
(set! @qvar{alist-var} (cons (cons @qvar{key} @qvar{val}) @qvar{alist-var}))
@end lisp
@end deffn


@deffn Syntax internal-body @qvaro{body} @qvar{body} @dots{}
Expand into:

@lisp
(let () @qvaro{body} @qvar{body} @dots{})
@end lisp
@end deffn


@deffn Syntax begin0 @qvar{expr} @qvaro{body} @qvar{body} @dots{}
Evaluate @qvar{expr} and save its return values; evaluate the @qvar{body} forms; finally return the
values returned by @qvar{expr}.

@lisp
(begin0
    (+ 1 2)
  (pretty-print 'here))
@result{} 3
@print{} here
@end lisp
@end deffn


@deffn Syntax begin-checks @qvaro{expr} @qvar{expr} @dots{}
Like @syntax{begin}, but wrap the whole form into the @chicken{} low--level operation
@syntax{##core#check}, so that: if unsafe compilation is enabled, the whole form expands to
no--operations.  @ChickenInternalsRef{checks unsafe, Including/excluding checks}.
@end deffn


@deffn Syntax xor @qvar{expr} @dots{}
Exclusive OR.
@end deffn

@c page
@node expr reexports
@section Reexported syntactic bindings


@cindex Reexported syntactic bindings
@findex @syntax{when}, reexported syntactic binding
@findex @syntax{unless}, reexported syntactic binding


The library @library{mmck lang} reexports the following syntactic bindings from @library{chicken
base}:

@lisp
when
unless
@end lisp

@c page
@node booleans
@chapter Boolean functions


@deffn Syntax boolean-true? @qvar{obj}
@deffnx Syntax boolean-false? @qvar{obj}
Predicates for the boolean objects @true{} and @false{}.
@end deffn

@c page
@node lists
@chapter List functions


The lists @api{} implemented by @value{PACKAGE} is inspired by that defined by @rnrs{6}; but there
are important differences.  Notice that:

@itemize
@item
The functions @strong{do not} check for circular lists.  If a list argument is circular: the
behaviour is undefined.

@item
The functions check their list arguments at the beginning, traversing the whole lists.  This
consumes resources.
@end itemize

@menu
* lists unsafe::                Basic unsafe list operations.
* lists cons::                  List constructors.
* lists pred::                  List predicates.
* lists getters::               Special list getters.
* lists fold::                  Folding lists.
* lists map::                   Mapping lists.
* lists search::                Searching lists.
* lists conditions::            Exceptional-condition object-types.
@end menu

@c page
@node lists unsafe
@section Basic unsafe list operations


@deffn {Unsafe Operation} $car @var{pair}
Like @func{car} but the operation is integrated at the call site and it does not check its
arguments.
@end deffn


@deffn {Unsafe Operation} $cdr @var{pair}
Like @func{cdr} but the operation is integrated at the call site and it does not check its
arguments.
@end deffn


@deffn {Unsafe Operation} $set-car! @var{pair} @var{new-value}
Like @func{set-car!} but the operation is integrated at the call site and it does not check its
arguments.
@end deffn


@deffn {Unsafe Operation} $set-cdr! @var{pair} @var{new-value}
Like @func{set-cdr!} but the operation is integrated at the call site and it does not check its
arguments.
@end deffn


@deffn {Unsafe Operation} $set-car-immediate! @var{pair} @var{new-value}
Like @func{set-car!} but the operation is integrated at the call site, it does not check its
arguments, and @var{new-value} must be an immediate value.
@end deffn


@deffn {Unsafe Operation} $set-cdr-immediate! @var{pair} @var{new-value}
Like @func{set-cdr!} but the operation is integrated at the call site, it does not check its
arguments, and @var{new-value} must be an immediate value.
@end deffn

@c page
@node lists cons
@section List constructors


@defun cons* @var{obj} @dots{} @var{tail}
Build and return a new list having the @var{obj} as first values and @var{tail} as tail.

@lisp
(cons* 1 '())           @result{} (1)
(cons* 1 2 '())         @result{} (1 2)
(cons* 1 2 3 '())       @result{} (1 2 3)

(cons* 1 '(2 3))        @result{} (1 2 3)
(cons* 1 2 3 '(4 5))    @result{} (1 2 3 4 5)
@end lisp
@end defun


@defun make-list @var{len}
@defunx make-list @var{len} @var{fill}
Build and return a new list of @var{len} pairs.  If @var{fill} is given: the cars of the pairs are
set to @var{fill}; @var{fill} defaults to the return value of @code{(void)}, where @func{void} is
the syntactic binding exported by @library{chicken base}.

@lisp
(make-list 0 'a)        @result{} ()
(make-list 3 'a)        @result{} (a a a)

(equal? (make-list 3)
        (list (void) (void) (void)))
@result{} #t
@end lisp
@end defun

@c page
@node lists pred
@section List predicates


@defun list-of-lists? @var{obj}
Return @true{} if @var{obj} is a (possibly empty) list of (possibly empty) lists; otherwise return
@false{}.  Notice that this function returns null if @var{obj} is neither null nor a proper list of
pairs.

@lisp
(list-of-lists? '())            @result{} #t
(list-of-lists? '(()))          @result{} #t
(list-of-lists? '(() ()))       @result{} #t
(list-of-lists? '(() () ()))    @result{} #t
(list-of-lists? '((1)))         @result{} #t
(list-of-lists? '((1) (2)))     @result{} #t
(list-of-lists? '((1) (2) (3))) @result{} #t

(list-of-lists? '(1 (2) (3)))   @result{} #f
(list-of-lists? '((1) 2 (3)))   @result{} #f
(list-of-lists? '((1) (2) 3))   @result{} #f

(list-of-lists? '#())           @result{} #f
@end lisp
@end defun


@defun list-of-nulls? @var{obj}
Return @true{} if @var{obj} is a (possibly empty) list of null objects; otherwise return @false{}.
Notice that this function returns @false{} if @var{obj} is neither null nor a proper list of nulls.

@lisp
(list-of-nulls? '())            @result{} #t
(list-of-nulls? '(()))          @result{} #t
(list-of-nulls? '(() ()))       @result{} #t
(list-of-nulls? '(() () ()))    @result{} #t

(list-of-nulls? '((1)))         @result{} #f
(list-of-nulls? '((1) (2)))     @result{} #f
(list-of-nulls? '((1) (2) (3))) @result{} #f

(list-of-nulls? '(1 (2) (3)))   @result{} #f
(list-of-nulls? '((1) 2 (3)))   @result{} #f
(list-of-nulls? '((1) (2) 3))   @result{} #f

(list-of-nulls? '#())           @result{} #f
@end lisp
@end defun


@defun list-of-pairs? @var{obj}
Return @true{} if @var{obj} is a (possibly empty) list of pair objects; otherwise return @false{}.
Notice that this function returns @false{} if @var{obj} is neither null nor a proper list of pairs.

@lisp
(list-of-pairs? '())            @result{} #t
(list-of-pairs? '((1)))         @result{} #t
(list-of-pairs? '((1) (2)))     @result{} #t
(list-of-pairs? '((1) (2) (3))) @result{} #t

(list-of-pairs? '(()))          @result{} #f
(list-of-pairs? '(() ()))       @result{} #f
(list-of-pairs? '(() () ()))    @result{} #f

(list-of-pairs? '(1 (2) (3)))   @result{} #f
(list-of-pairs? '((1) 2 (3)))   @result{} #f
(list-of-pairs? '((1) (2) 3))   @result{} #f

(list-of-pairs? '#())           @result{} #f
@end lisp
@end defun


@defun lists-of-lists-of-equal-length? @var{obj}
Return @true{} if @var{obj} is a (possibly empty) list of (possibly empty) lists of equal length;
otherwise return @false{}.  Notice that this function returns @false{} if @var{obj} is neither null
nor a proper list of pairs.

@lisp
(lists-of-lists-of-equal-length? '())                   @result{} #t
(lists-of-lists-of-equal-length? '(()))                 @result{} #t
(lists-of-lists-of-equal-length? '(() ()))              @result{} #t
(lists-of-lists-of-equal-length? '(() () ()))           @result{} #t
(lists-of-lists-of-equal-length? '((1)))                @result{} #t
(lists-of-lists-of-equal-length? '((1) (2)))            @result{} #t
(lists-of-lists-of-equal-length? '((1) (2) (3)))        @result{} #t

(lists-of-lists-of-equal-length? '(() (2) (3)))         @result{} #f
(lists-of-lists-of-equal-length? '((1) () (3)))         @result{} #f
(lists-of-lists-of-equal-length? '((1) (2) ()))         @result{} #f
(lists-of-lists-of-equal-length? '((1 0) (2) (3)))      @result{} #f
(lists-of-lists-of-equal-length? '((1) (2 0) (3)))      @result{} #f
(lists-of-lists-of-equal-length? '((1) (2) (3 0)))      @result{} #f

(lists-of-lists-of-equal-length? '((1 2 3 4 5)))        @result{} #t
(lists-of-lists-of-equal-length? '((1 2 3 4 5)
                                   (6 7 8 9 0)))        @result{} #t
(lists-of-lists-of-equal-length? '((1 2 3 4 5)
                                   (6 7 8 9 0)
                                   (9 8 7 6 5)))        @result{} #t

(lists-of-lists-of-equal-length? 123)                   @result{} #f
@end lisp
@end defun


@defun lists-of-equal-length? @varo{obj} @var{obj} @dots{}
Return @true{} if all the arguments are (possibly empty) lists of equal length; otherwise return
@false{}.  Notice that this function returns @false{} if one of the arguments is neither null nor a
proper list of pairs.

@lisp
(lists-of-equal-length? '())                    @result{} #t
(lists-of-equal-length? '() '())                @result{} #t
(lists-of-equal-length? '() '() '())            @result{} #t
(lists-of-equal-length? '(1))                   @result{} #t
(lists-of-equal-length? '(1) '(2))              @result{} #t
(lists-of-equal-length? '(1) '(2) '(3))         @result{} #t

(lists-of-equal-length? '() '(2) '(3))          @result{} #f
(lists-of-equal-length? '(1) '() '(3))          @result{} #f
(lists-of-equal-length? '(1) '(2) '())          @result{} #f
(lists-of-equal-length? '(1 0) '(2) '(3))       @result{} #f
(lists-of-equal-length? '(1) '(2 0) '(3))       @result{} #f
(lists-of-equal-length? '(1) '(2) '(3 0))       @result{} #f

(lists-of-equal-length? '(1 2 3 4 5))           @result{} #t
(lists-of-equal-length? '(1 2 3 4 5)
                        '(6 7 8 9 0))           @result{} #t
(lists-of-equal-length? '(1 2 3 4 5)
                        '(6 7 8 9 0)
                        '(9 8 7 6 5))           @result{} #t

(lists-of-equal-length? 123)                    @result{} #f
@end lisp
@end defun

@c page
@node lists getters
@section Special list getters


@defun cars-and-cdrs @var{list-of-lists}
@defunx cars-and-cdrs @var{list-of-lists} @var{cars-tail}
The argument @var{list-of-lists} must be a non--empty list of non--empty lists.  Return two values:

@enumerate
@item
A list of the CARs of the lists in @var{list-of-lists}.

@item
A list of the CDRs of the lists in @var{list-of-lists}.
@end enumerate

The optional argument @var{cars-tail} is appended to the cars list; it defaults to null.

@lisp
(cars-and-cdrs '((1 2 3)
                 (4 5 6)))
@result{} (1 4) ((2 3) (5 6))

(cars-and-cdrs '((1 2 3)
                 (4 5 6)
                 (7 8 9)))
@result{} (1 4 7) ((2 3) (5 6) (8 9))

(cars-and-cdrs '((1 2 3)
                 (4 5 6))
               '(a b))
@result{} (1 4 a b) ((2 3) (5 6))

(cars-and-cdrs '((1 2 3)
                 (4 5 6)
                 (7 8 9))
               '(a b))
@result{} (1 4 7 a b) ((2 3) (5 6) (8 9))
@end lisp
@end defun



@defun gather-cars-in-reverse @var{list-of-lists}
@defunx gather-cars-in-reverse @var{list-of-lists} @var{cars-tail}
The argument @var{list-of-lists} must be a (possibly empty) list of (possibly empty) lists.  Return
a list of lists, each sublist being the lists of cars built by iterating through @var{list-of-lists}
from the end.  The optional argument @var{cars-tail} is appended to each cars list; it defaults to
null.

The returned value is the list of lists we would need to implement @func{fold-right}.

@lisp
(gather-cars-in-reverse '())            @result{} ()
(gather-cars-in-reverse '(()))          @result{} ()
(gather-cars-in-reverse '(() ()))       @result{} ()
(gather-cars-in-reverse '(() () ()))    @result{} ()
(gather-cars-in-reverse '((1) (4) (7))) @result{} ((1 4 7))

(gather-cars-in-reverse '((1 2 3)
                          (4 5 6)
                          (7 8 9)))
@result{} ((3 6 9)
    (2 5 8)
    (1 4 7))

(define tail '(a b))

(gather-cars-in-reverse '()            tail) @result{} ()
(gather-cars-in-reverse '(())          tail) @result{} ()
(gather-cars-in-reverse '(() ())       tail) @result{} ()
(gather-cars-in-reverse '(() () ())    tail) @result{} ()
(gather-cars-in-reverse '((1) (4) (7)) tail) @result{} ((1 4 7 a b))

(gather-cars-in-reverse '((1 2 3)
                          (4 5 6)
                          (7 8 9))
                        tail)
@result{} ((3 6 9 a b)
    (2 5 8 a b)
    (1 4 7 a b))
@end lisp
@end defun


@defun butlast-and-last @var{ell}
The argument @var{ell} must be a (possibly empty) proper list.  Return two values:

@enumerate
@item
The list of all the items in @var{ell} but the last.

@item
The last item in @var{ell}.
@end enumerate

@lisp
(butlast-and-last '())               @error{} &list-is-empty
(butlast-and-last '(0))              @result{} () 0
(butlast-and-last '(0 1))            @result{} (0) 1
(butlast-and-last '(0 1 2))          @result{} (0 1) 2
(butlast-and-last '(0 1 2 3))        @result{} (0 1 2) 3
(butlast-and-last '(0 1 2 3 4))      @result{} (0 1 2 3) 4
(butlast-and-last '(0 1 2 3 4 5))    @result{} (0 1 2 3 4) 5
(butlast-and-last '(0 1 2 3 4 5 6))  @result{} (0 1 2 3 4 5) 6
@end lisp
@end defun

@c page
@node lists fold
@section Folding lists


@defun fold-left @var{combine} @var{nil} @vari{list} @varii{list} @dots{} @varn{list}
The @var{list}s must all have the same length.  @var{combine} must be a procedure; it must accept
one more argument than there are @var{list}s and return a single value; it must not mutate the
@var{list} arguments.

The @func{fold-left} procedure iterates the @var{combine} procedure over an accumulator value and
the elements of the @var{list}s from left to right, starting with an accumulator value of @var{nil}.
@var{combine} must have signature:

@lisp
(lambda (nil item0 item ...) . @meta{body})
@end lisp

More specifically, @func{fold-left} returns @var{nil} if the @var{list}s are empty.  If they are not
empty, @var{combine} is first applied to @var{nil} and the respective first elements of the
@var{list}s in order.  The result becomes the new accumulator value, and @var{combine} is applied to
the new accumulator value and the respective next elements of the @var{list}.  This step is repeated
until the end of the list is reached; then the accumulator value is returned.

@var{combine} is always called in the same dynamic environment as @func{fold-left} itself.

@lisp
(fold-left + 0 '(1 2 3 4 5))
@result{} 15

(fold-left
    (lambda (a e)
      (cons e a))
  '()
  '(1 2 3 4 5))
@result{} (5 4 3 2 1)

(fold-left
    (lambda (count x)
      (if (odd? x)
          (+ count 1)
        count))
  0
  '(3 1 4 1 5 9 2 6 5 3))
@result{} 7

(fold-left
    (lambda (max-len s)
      (max max-len (string-length s)))
  0
  '("longest" "long" "longer"))
@result{} 7

(fold-left cons '(q) '(a b c))
@result{} ((((q) . a) . b) . c)

(fold-left + 0 '(1 2 3) '(4 5 6))
@result{} 21
@end lisp
@end defun


@defun fold-right @var{combine} @var{nil} @vari{list} @varii{list} @dots{} @varn{list}
The @var{list}s must all have the same length.  @var{combine} must be a procedure; it must accept
one more argument than there are @var{list}s and return a single value; @var{combine} must not
mutate the @var{list} arguments.

The @func{fold-right} procedure iterates the @var{combine} procedure over the elements of the
@var{list}s from right to left and an accumulator value, starting with an accumulator value of
@var{nil}; @var{combine} must have signature:

@lisp
(lambda (item0 item ... nil) . @meta{body})
@end lisp

More specifically, @func{fold-right} returns @var{nil} if the @var{list}s are empty.  If they are
not empty, @var{combine} is first applied to the respective last elements of the @var{list}s in
order and @var{nil}.  The result becomes the new accumulator value, and @var{combine} is applied to
the respective previous elements of the @var{list}s and the new accumulator value.  This step is
repeated until the beginning of the list is reached; then the accumulator value is returned.

@var{proc} is always called in the same dynamic environment as @func{fold-right} itself.

@lisp
(fold-right + 0 '(1 2 3 4 5))
@result{} 15

(fold-right cons '() '(1 2 3 4 5))
@result{} (1 2 3 4 5)

(fold-right
    (lambda (item knil)
      (cons item knil))
  '()
  '(1 2 3 4))
@result{} (1 2 3 4)

(fold-right
    (lambda (x l)
      (if (odd? x) (cons x l) l))
  '()
  '(3 1 4 1 5 9 2 6 5))
@result{} (3 1 1 5 9 5)

(fold-right cons '(q) '(a b c))
@result{} (a b c q)

(fold-right + 0 '(1 2 3) '(4 5 6))
@result{} 21
@end lisp
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe left--folding procedures


@defun {$fold-left/1} @var{combine} @var{nil} @var{ell}
Like @func{fold-left} for a single list argument, but does not validate its arguments.
@end defun


@defun {$fold-left/2} @var{combine} @var{nil} @vari{ell} @varii{ell}
Like @func{fold-left} for two list arguments, but does not validate its arguments.
@end defun


@defun {$fold-left/3} @var{combine} @var{nil} @vari{ell} @varii{ell} @variii{ell}
Like @func{fold-left} for three list arguments, but does not validate its arguments.
@end defun


@defun {$fold-left/list} @var{combine} @var{nil} @var{list-of-lists}
Like @func{fold-left} for any number list operands, but does not validate its arguments.  All the
list operands must be in the @var{list-of-lists}.

@lisp
($fold-left/list
    (lambda (knil item1 item2 item3 item4)
      (list knil item1 item2 item3 item4))
  0
  '((1 2 3 4)
    (5 6 7 8)
    (9 1 2 3)
    (4 5 6 7)))
@result{} ((((0 1 5 9 4) 2 6 1 5) 3 7 2 6) 4 8 3 7)
@end lisp
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe right--folding procedures


@defun {$fold-right/1} @var{combine} @var{nil} @var{ell}
Like @func{fold-right} for a single list argument, but does not validate its arguments.
@end defun


@defun {$fold-right/2} @var{combine} @var{nil} @vari{ell} @varii{ell}
Like @func{fold-right} for two list arguments, but does not validate its arguments.
@end defun


@defun {$fold-right/3} @var{combine} @var{nil} @vari{ell} @varii{ell} @variii{ell}
Like @func{fold-right} for three list arguments, but does not validate its arguments.
@end defun


@defun {$fold-right/list} @var{combine} @var{nil} @var{list-of-lists}
Like @func{fold-right} for any number list operands, but does not validate its arguments.  All the
list operands must be in the @var{list-of-lists}.

@lisp
($fold-right/list
    (lambda (item1 item2 item3 item4 item5 knil)
      (cons (list item1 item2 item3 item4 item5) knil))
  0
  '((1 2 3 4)
    (5 6 7 8)
    (9 1 2 3)
    (4 5 6 7)
    (a b c d)))
@result{} ((1 5 9 4 a) (2 6 1 5 b) (3 7 2 6 c) (4 8 3 7 d) . 0)
@end lisp
@end defun

@c page
@node lists map
@section Mapping lists


@defun map-in-order @var{proc} @vari{list} @varii{list} @dots{}
The @var{list}s must all have the same length.  @var{proc} must accept as many arguments as there
are @var{list}s and return a single value.  @var{proc} must not mutate any of the @var{list}s.

The @func{map-in-order} procedure applies @var{proc} element--wise to the elements of the
@var{list}s, left to right, and returns a list of the results, in order.  @var{proc} is always
called in the same dynamic environment as @func{map-in-order} itself.  If multiple returns occur
from @func{map-in-order}, the values returned by earlier returns are not mutated.

@lisp
(map cadr '((a b) (d e) (g h)))         @result{}  (b e h)

(map (lambda (n) (expt n n))
     '(1 2 3 4 5))                      @result{}  (1 4 27 256 3125)

(map + '(1 2 3) '(4 5 6))               @result{}  (5 7 9)

(let ((count 0))
  (map (lambda (ignored)
         (set! count (+ count 1))
         count)
       '(a b)))                         @result{}  (1 2) or (2 1)
@end lisp
@end defun


@defun for-each-in-order @var{proc} @vari{list} @varii{list} @dots{}
The @var{list}s must all have the same length.  @var{proc} must accept as many arguments as there
are @var{list}s.  @var{proc} must not mutate any of the @var{list}s.

The @func{for-each-in-order} procedure applies @var{proc} element--wise to the elements of the
@var{list}s for its side effects, in order from the first elements to the last.  @var{proc} is
always called in the same dynamic environment as @func{for-each-in-order} itself.  The return values
of @func{for-each-in-order} are unspecified.

@lisp
(let ((v (make-vector 5)))
  (for-each-in-order
      (lambda (i)
        (vector-set! v i (* i i)))
    '(0 1 2 3 4))
  v)
@result{}  #(0 1 4 9 16)

(for-each-in-order (lambda (x) x) '(1 2 3 4))
@result{} unspecified

(for-each-in-order even? '())
@result{} unspecified
@end lisp
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe mapping procedures


@defun {$map/1} @var{func} @var{ell}
Like @func{map} for a single list argument, but does not validate its arguments.
@end defun


@defun {$map/2} @var{func} @vari{ell} @varii{ell}
Like @func{map} for two list arguments, but does not validate its arguments.
@end defun


@defun {$map/3} @var{func} @vari{ell} @varii{ell} @variii{ell}
Like @func{map} for three list arguments, but does not validate its arguments.
@end defun


@defun {$map/list} @var{func} @var{list-of-lists}
Like @func{map} for any number list operands, but does not validate its arguments.  All the list
operands must be in the @var{list-of-lists}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe iteration procedures


@defun {$for-each/1} @var{func} @var{ell}
Like @func{for-each} for a single list argument, but does not validate its arguments.
@end defun


@defun {$for-each/2} @var{func} @vari{ell} @varii{ell}
Like @func{for-each} for two list arguments, but does not validate its arguments.
@end defun


@defun {$for-each/3} @var{func} @vari{ell} @varii{ell} @variii{ell}
Like @func{for-each} for three list arguments, but does not validate its arguments.
@end defun


@defun {$for-each/list} @var{func} @var{list-of-lists}
Like @func{for-each} for any number list operands, but does not validate its arguments.  All the
list operands must be in the @var{list-of-lists}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe in--order mapping procedures


@defun {$map-in-order/1} @var{func} @var{ell}
Like @func{map-in-order} for a single list argument, but does not validate its arguments.
@end defun


@defun {$map-in-order/2} @var{func} @vari{ell} @varii{ell}
Like @func{map-in-order} for two list arguments, but does not validate its arguments.
@end defun


@defun {$map-in-order/3} @var{func} @vari{ell} @varii{ell} @variii{ell}
Like @func{map-in-order} for three list arguments, but does not validate its arguments.
@end defun


@defun {$map-in-order/list} @var{func} @var{list-of-lists}
Like @func{map-in-order} for any number list operands, but does not validate its arguments.  All the
list operands must be in the @var{list-of-lists}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe in--order iteration procedures


@defun {$for-each-in-order/1} @var{func} @var{ell}
Like @func{for-each-in-order} for a single list argument, but does not validate its arguments.
@end defun


@defun {$for-each-in-order/2} @var{func} @vari{ell} @varii{ell}
Like @func{for-each-in-order} for two list arguments, but does not validate its arguments.
@end defun


@defun {$for-each-in-order/3} @var{func} @vari{ell} @varii{ell} @variii{ell}
Like @func{for-each-in-order} for three list arguments, but does not validate its arguments.
@end defun


@defun {$for-each-in-order/list} @var{func} @var{list-of-lists}
Like @func{for-each-in-order} for any number list operands, but does not validate its arguments.
All the list operands must be in the @var{list-of-lists}.
@end defun

@c page
@node lists search
@section Searching lists


@defun find @var{proc} @var{list}
@var{proc} must accept one argument and return a single value.  @var{proc} must not mutate
@var{list}.  The @func{find} procedure applies @var{proc} to the elements of @var{list} in order.
If @var{proc} returns a true value for an element, @func{find} immediately returns that element.  If
@var{proc} returns @false{} for all elements of the list, @func{find} returns @false{}.  @var{proc}
is always called in the same dynamic environment as @func{find} itself.

@lisp
(find even? '(3 1 4 1 5 9))
@result{} 4

(find even? '(3 1 5 1 5 9))
@result{} #f
@end lisp
@end defun


@defun for-all @var{proc} @vari{list} @varii{list} @dots{} @varn{list}
The @var{list}s must all have the same length, and @var{proc} must accept @math{n} arguments and
return a single value.  @var{proc} must not mutate the @var{list} arguments.

For natural numbers @math{i = 0, 1, @dots{}}, the @func{for-all} procedure successively applies
@var{proc} to arguments @math{x_i^1 @dots{} x_i^n}, where @math{x_i^j} is the @math{i}-th element of
@varj{list}, until @false{} is returned.

If @var{proc} returns true values for all but the last element of the @var{list} arguments:
@func{for-all} performs a tail call of @var{proc} on the elements @math{k-1}, where @math{k} is the
length of the lists.  If @var{proc} returns @false{} on any set of elements: @func{for-all} returns
@false{} after the first such application of @var{proc}.  If the @var{list}s are all empty,
@func{for-all} returns @true{}.

@var{proc} is always called in the same dynamic environment as @func{for-all} itself.

@lisp
(for-all even? '(3 1 4 1 5 9))
@result{} #f

(for-all even? '(3 1 4 1 5 9 . 2))
@result{} #f

(for-all even? '(2 4 14))
@result{} #t

(for-all even? '(2 4 14 . 9))
@error{} exception &assertion

(for-all (lambda (n) (and (even? n) n))
         '(2 4 14))
@result{} 14

(for-all < '(1 2 3) '(2 3 4))
@result{} #t

(for-all < '(1 2 4) '(2 3 4))
@result{} #f

@end lisp
@end defun


@defun exists @var{proc} @vari{list} @varii{list} @dots{} @varn{list}
The @var{list}s must all have the same length, and @var{proc} must accept @math{n} arguments and
return a single value.  @var{proc} must not mutate the @var{list} arguments.

For natural numbers @math{i = 0, 1, @dots{}}, the @func{exists} procedure applies @var{proc}
successively to arguments @math{x_i^1 @dots{} x_i^n}, where @math{x_i^j} is the @math{i}-th element
of @var{listj}, until a true value is returned.

If @var{proc} returns @false{} for all but the last elements of the @var{list} arguments:
@func{exists} performs a tail call of @var{proc} on the elements @math{k-1} elements, where @math{k}
is the length of the lists.  If @var{proc} returns a true value on any set of elements,
@func{exists} returns that value after the first such application of @var{proc}.  If the @var{list}s
are all empty, @func{exists} returns @false{}.

@var{proc} is always called in the same dynamic environment as @func{for-all} or, respectively,
@func{exists} itself.

@lisp
(exists even? '(3 1 4 1 5 9))
@result{} #t

(exists even? '(3 1 1 5 9))
@result{} #f

(exists even? '(3 1 1 5 9 . 2))
@error{} exception &assertion

(exists (lambda (n) (and (even? n) n))
        '(2 1 4 14))
@result{} 2

(exists < '(1 2 4) '(2 3 4))
@result{} #t

(exists > '(1 2 3) '(2 3 4))
@result{} #f
@end lisp
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe finding


@defun {$find} @var{pred} @var{ell}
Like @func{find}, but does not validate its arguments.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe searching ``for all'' procedures


@defun {$for-all/1} @var{pred} @var{ell}
Like @func{for-all} for a single list argument, but does not validate its arguments.
@end defun


@defun {$for-all/2} @var{pred} @vari{ell} @varii{ell}
Like @func{for-all} for two list arguments, but does not validate its arguments.
@end defun


@defun {$for-all/3} @var{pred} @vari{ell} @varii{ell} @variii{ell}
Like @func{for-all} for three list arguments, but does not validate its arguments.
@end defun


@defun {$for-all/list} @var{pred} @var{list-of-lists}
Like @func{for-all} for any number list operands, but does not validate its arguments.  All the list
operands must be in the @var{list-of-lists}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe searching ``exists'' procedures


@defun {$exists/1} @var{pred} @var{ell}
Like @func{exists} for a single list argument, but does not validate its arguments.
@end defun


@defun {$exists/2} @var{pred} @vari{ell} @varii{ell}
Like @func{exists} for two list arguments, but does not validate its arguments.
@end defun


@defun {$exists/3} @var{pred} @vari{ell} @varii{ell} @variii{ell}
Like @func{exists} for three list arguments, but does not validate its arguments.
@end defun


@defun {$exists/list} @var{pred} @var{list-of-lists}
Like @func{exists} for any number list operands, but does not validate its arguments.  All the list
operands must be in the @var{list-of-lists}.
@end defun

@c page
@node lists conditions
@section Exceptional--condition object--types


@menu
* lists conditions is empty::   Exceptional condition: @condition{list-is-empty}.
* lists conditions diff len::   Exceptional condition: @condition{lists-are-of-different-length}.
* lists conditions empty len::  Exceptional condition: @condition{lists-are-empty-or-of-different-length}.
@end menu

@c page
@node lists conditions is empty
@subsection Exceptional condition: @condition{list-is-empty}


@deftp {Condition Object} @acondition{list-is-empty}
Exceptional--condition object--type representing an invalid empty list operand: a non--empty proper
list was expected.
@end deftp


@defun make-list-is-empty-condition
Build and return a new exceptional--condition object of type @condition{list-is-empty}.
@end defun


@defun condition-list-is-empty? @var{obj}
Return @true{} if @var{obj} is an exceptional--condition object of type @condition{list-is-empty} or
a compound condition object having a component of type @condition{list-is-empty}; otherwise return
@false{}.
@end defun


@defun raise-exception-list-is-empty @var{who} @var{obj}
Raise a non--continuable exception with compound condition object having components:
@condition{list-is-empty}; @condition{who}; @condition{message}; @condition{irritants}.
@end defun

@c page
@node lists conditions diff len
@subsection Exceptional condition: @condition{lists-are-of-different-length}


@deftp {Condition Object} @acondition{lists-are-of-different-length}
Exceptional--condition object--type representing invalid list operands: a proper lists with the same
length were expected.
@end deftp


@defun make-lists-are-of-different-length-condition
Build and return a new exceptional--condition object of type
@condition{lists-are-of-different-length}.
@end defun


@defun condition-lists-are-of-different-length? @var{obj}
Return @true{} if @var{obj} is an exceptional--condition object of type
@condition{lists-are-of-different-length} or a compound condition object having a component of type
@condition{lists-are-of-different-length}; otherwise return @false{}.
@end defun


@defun raise-exception-lists-are-of-different-length @var{who} @var{obj}
Raise a non--continuable exception with compound condition object having components:
@condition{lists-are-of-different-length}; @condition{who}; @condition{message};
@condition{irritants}.
@end defun

@c page
@node lists conditions empty len
@subsection Exceptional condition: @condition{lists-are-empty-or-of-different-length}


@deftp {Condition Object} @acondition{lists-are-empty-or-of-different-length}
Exceptional--condition object--type representing invalid list operands: a proper lists with the same
length were expected.
@end deftp


@defun make-lists-are-empty-or-of-different-length-condition
Build and return a new exceptional--condition object of type
@condition{lists-are-empty-or-of-different-length}.
@end defun


@defun condition-lists-are-empty-or-of-different-length? @var{obj}
Return @true{} if @var{obj} is an exceptional--condition object of type
@condition{lists-are-empty-or-of-different-length} or a compound condition object having a component of type
@condition{lists-are-empty-or-of-different-length}; otherwise return @false{}.
@end defun


@defun raise-exception-lists-are-empty-or-of-different-length @var{who} @var{obj}
Raise a non--continuable exception with compound condition object having components:
@condition{lists-are-empty-or-of-different-length}; @condition{who}; @condition{message};
@condition{irritants}.
@end defun

@c page
@node vectors
@chapter Vector functions


The vectors @api{} implemented by @value{PACKAGE} is inspired by that defined by @rnrs{6} for lists.

@menu
* vectors unsafe::              Unsafe operations on vectors.
* vectors cons::                Vector constructors.
* vectors pred::                Vector predicates.
* vectors fold::                Folding vectors.
* vectors map::                 Mapping vectors.
* vectors search::              Searching vectors.
* vectors copy::                Copying vectors.
* vectors sort::                Sorted vectors.
* vectors conditions::          Exceptional-condition object-types.
@end menu

@c page
@node vectors unsafe
@section Unsafe operations on vectors


@deffn {Unsafe Operation} $vector-length @var{vec}
The argument @var{vec} must be a vector object.  Return a non--negative fixnum representing the
length of the vector @var{vec}.
@end deffn


@deffn {Unsafe Operation} $vector-ref @var{vec} @var{fxidx}
The argument @var{vec} must be a vector object.  The argument @var{fxidx} must be a non--negative
integer representing a valid index in the vector @var{vec}.  Return the object at index @var{fxidx}
in the vector @var{vec}.
@end deffn


@deffn {Unsafe Operation} $vector-set! @var{vec} @var{fxidx} @var{obj}
The argument @var{vec} must be a vector object.  The argument @var{fxidx} must be a non--negative
integer representing a valid index in the vector @var{vec}.  Store the object @var{obj} at index
@var{fxidx} in the vector @var{vec}; return unspecified values.
@end deffn


@deffn {Unsafe Operation} $vector-set-immediate! @var{vec} @var{fxidx} @var{imm-obj}
The argument @var{vec} must be a vector object.  The argument @var{fxidx} must be a non--negative
integer representing a valid index in the vector @var{vec}.  Store the immediate object
@var{imm-obj} at index @var{fxidx} in the vector @var{vec}; return unspecified values.  This
operation is a bit faster than @func{$vector-set!}.
@end deffn

@c page
@node vectors cons
@section Vector constructors


@defun vector-append @var{vec} @dots{}
Return a newly allocated vector whose items form the concatenation of the given vectors.

@lisp
(vector-append '#() '#() '#())
@result{} #()

(vector-append '#(a b c) '#() '#())
@result{} #(a b c)

(vector-append '#(a b c) '#(d e) '#(f g h i))
@result{} #(a b c d e f g h i)
@end lisp
@end defun

@c page
@node vectors pred
@section Vector predicates


@defun vector-empty? @var{obj}
Return @true{} if @var{obj} is a vector object and it is empty (that is: of zero length); otherwise
return @false{}.
@end defun


@defun vector-not-empty? @var{obj}
Return @true{} if @var{obj} is a vector object and it is not empty (that is: of length greater than
zero); otherwise return @false{}.
@end defun


@defun list-of-vectors? @var{obj}
Return @true{} if @var{obj} is a (possibly empty) list of (possibly empty) vectors; otherwise return
@false{}.  Notice that this function returns null if @var{obj} is neither null nor a proper list of
vectors.
@end defun


@defun list-of-vectors-of-equal-length? @var{obj}
Return @true{} if @var{obj} is a (possibly empty) list of (possibly empty) vectors of equal length;
otherwise return @false{}.  Notice that this function returns @false{} if @var{obj} is neither null
nor a proper list of vectors.
@end defun


@defun vectors-of-equal-length? @varo{obj} @var{obj} @dots{}
Return @true{} if all the arguments are (possibly empty) vectors of equal length; otherwise return
@false{}.  Notice that this function returns @false{} if one of the arguments is not a vector.
@end defun

@c page
@node vectors fold
@section Folding vectors


@defun vector-fold-left @var{combine} @var{nil} @vari{vector} @varii{vector} @dots{} @varn{vector}
The @var{vector}s must all have the same length.  @var{combine} must be a procedure; it must accept
one more argument than there are @var{vector}s and return a single value; it must not mutate the
@var{vector} arguments.

The @func{vector-fold-left} procedure iterates the @var{combine} procedure over an accumulator value
and the elements of the @var{vector}s from left to right, starting with an accumulator value of
@var{nil}.  @var{combine} must have signature:

@lisp
(lambda (nil item0 item ...) . @meta{body})
@end lisp

More specifically, @func{vector-fold-left} returns @var{nil} if the @var{vector}s are empty.  If
they are not empty, @var{combine} is first applied to @var{nil} and the respective first elements of
the @var{vector}s in order.  The result becomes the new accumulator value, and @var{combine} is
applied to the new accumulator value and the respective next elements of the @var{vector}.  This
step is repeated until the end of the vector is reached; then the accumulator value is returned.

@var{combine} is always called in the same dynamic environment as @func{vector-fold-left} itself.

@lisp
(vector-fold-left
    (lambda (knil item)
      (cons item knil))
  '(0)
  '#(a b c))
@result{} (c b a 0)
@end lisp
@end defun


@defun vector-fold-right @var{combine} @var{nil} @vari{vector} @varii{vector} @dots{} @varn{vector}
The @var{vector}s must all have the same length.  @var{combine} must be a procedure; it must accept
one more argument than there are @var{vector}s and return a single value; @var{combine} must not
mutate the @var{vector} arguments.

The @func{vector-fold-right} procedure iterates the @var{combine} procedure over the elements of the
@var{vector}s from right to left and an accumulator value, starting with an accumulator value of
@var{nil}; @var{combine} must have signature:

@lisp
(lambda (item0 item ... nil) . @meta{body})
@end lisp

More specifically, @func{vector-fold-right} returns @var{nil} if the @var{vector}s are empty.  If they are
not empty, @var{combine} is first applied to the respective last elements of the @var{vector}s in
order and @var{nil}.  The result becomes the new accumulator value, and @var{combine} is applied to
the respective previous elements of the @var{vector}s and the new accumulator value.  This step is
repeated until the beginning of the vector is reached; then the accumulator value is returned.

@var{proc} is always called in the same dynamic environment as @func{vector-fold-right} itself.

@lisp
(vector-fold-right
    (lambda (item knil)
      (cons item knil))
  '(0)
  '#(a b c))
@result{} (a b c 0)
@end lisp
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe left--folding procedures


@defun {$vector-fold-left/1} @var{combine} @var{nil} @var{vec}
Like @func{vector-fold-left} for a single vector argument, but does not validate its arguments.
@end defun


@defun {$vector-fold-left/2} @var{combine} @var{nil} @vari{vec} @varii{vec}
Like @func{vector-fold-left} for two vector arguments, but does not validate its arguments.
@end defun


@defun {$vector-fold-left/3} @var{combine} @var{nil} @vari{vec} @varii{vec} @variii{vec}
Like @func{vector-fold-left} for three vector arguments, but does not validate its arguments.
@end defun


@defun {$vector-fold-left/list} @var{combine} @var{nil} @var{list-of-vectors}
Like @func{vector-fold-left} for any number vector operands, but does not validate its arguments.
All the vector operands must be in the @var{list-of-vectors}.

@lisp
($vector-fold-left/list
     (lambda (knil item1 item2 item3 item4)
       (cons (list item1 item2 item3 item4) knil))
   '(0)
   '(#(a b c)
     #(d e f)
     #(g h i)
     #(l m n)))
@result{} ((c f i n) (b e h m) (a d g l) 0)
@end lisp
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe right--folding procedures


@defun {$vector-fold-right/1} @var{combine} @var{nil} @var{vec}
Like @func{vector-fold-right} for a single vector argument, but does not validate its arguments.
@end defun


@defun {$vector-fold-right/2} @var{combine} @var{nil} @vari{vec} @varii{vec}
Like @func{vector-fold-right} for two vector arguments, but does not validate its arguments.
@end defun


@defun {$vector-fold-right/3} @var{combine} @var{nil} @vari{vec} @varii{vec} @variii{vec}
Like @func{vector-fold-right} for three vector arguments, but does not validate its arguments.
@end defun


@defun {$vector-fold-right/list} @var{combine} @var{nil} @var{list-of-vectors}
Like @func{vector-fold-right} for any number vector operands, but does not validate its arguments.
All the vector operands must be in the @var{list-of-vectors}.

@lisp
($vector-fold-right/list
    (lambda (item1 item2 item3 item4 knil)
      (cons (list item1 item2 item3 item4) knil))
  '(0)
  '(#(a b c)
    #(d e f)
    #(g h i)
    #(l m n)))
@result{} ((a d g l) (b e h m) (c f i n) 0)
@end lisp
@end defun

@c page
@node vectors map
@section Mapping vectors


@menu
* vectors map plain::           Traditional vectors mapping.
* vectors map index::           Vectors mapping with indexes.
@end menu

@c page
@node vectors map plain
@subsection Traditional vectors mapping


@defun vector-map @var{proc} @vari{vector} @varii{vector} @dots{}
@defunx vector-map-in-order @var{proc} @vari{vector} @varii{vector} @dots{}
The @var{vector}s must all have the same length.  @var{proc} must accept as many arguments as there
are @var{vector}s and return a single value.  @var{proc} must not mutate any of the @var{vector}s.

The syntactic binding @func{vector-map-in-order} is an alias for @func{vector-map}.

The @func{vector-map} procedure applies @var{proc} element--wise to the elements of the
@var{vector}s, left to right, and return a vector of the results, in order.  @var{proc} is always
called in the same dynamic environment as @func{vector-map} itself.  If multiple returns occur from
@func{vector-map}, the values returned by earlier returns are not mutated.

@lisp
(vector-map
    (lambda (item)
      (list item))
  '#(a b c))
@result{} #((a) (b) (c))

(vector-map
    (lambda (item1 item2)
      (list item1 item2))
  '#(a b c)
  '#(d e f))
@result{} #((a d) (b e) (c f))
@end lisp
@end defun


@defun vector-for-each @var{proc} @vari{vector} @varii{vector} @dots{}
@defunx vector-for-each-in-order @var{proc} @vari{vector} @varii{vector} @dots{}
The @var{vector}s must all have the same length.  @var{proc} must accept as many arguments as there
are @var{vector}s.  @var{proc} must not mutate any of the @var{vector}s.

The syntactic binding @func{vector-for-each-in-order} is an alias for @func{vector-for-each}.

The @func{vector-for-each} procedure applies @var{proc} element--wise to the elements of the
@var{vector}s for its side effects, in order from the first elements to the last.  @var{proc} is
always called in the same dynamic environment as @func{vector-for-each} itself.  The return values
of @func{vector-for-each} are unspecified.

@lisp
(let ((v (make-vector 5)))
  (vector-for-each
      (lambda (i)
        (vector-set! v i (* i i)))
    '#(0 1 2 3 4))
  v)
@result{} #(0 1 4 9 16)

(vector-for-each (lambda (x) x) '#(1 2 3 4))
@result{} unspecified

(vector-for-each even? '#())
@result{} unspecified
@end lisp
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe mapping procedures


@defun {$vector-map/1} @var{func} @var{ell}
@defunx {$vector-map-in-order/1} @var{func} @var{ell}
Like @func{vector-map} for a single vector argument, but does not validate its arguments.
@end defun


@defun {$vector-map/2} @var{func} @vari{ell} @varii{ell}
@defunx {$vector-map-in-order/2} @var{func} @vari{ell} @varii{ell}
Like @func{vector-map} for two vector arguments, but does not validate its arguments.
@end defun


@defun {$vector-map/3} @var{func} @vari{ell} @varii{ell} @variii{ell}
@defunx {$vector-map-in-order/3} @var{func} @vari{ell} @varii{ell} @variii{ell}
Like @func{vector-map} for three vector arguments, but does not validate its arguments.
@end defun


@defun {$vector-map/list} @var{func} @var{list-of-vectors}
@defunx {$vector-map-in-order/list} @var{func} @var{list-of-vectors}
Like @func{vector-map} for any number vector operands, but does not validate its arguments.  All the
vector operands must be in the @var{list-of-vectors}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe iteration procedures


@defun {$vector-for-each/1} @var{func} @var{ell}
@defunx {$vector-for-each-in-order/1} @var{func} @var{ell}
Like @func{vector-for-each} for a single vector argument, but does not validate its arguments.
@end defun


@defun {$vector-for-each/2} @var{func} @vari{ell} @varii{ell}
@defunx {$vector-for-each-in-order/2} @var{func} @vari{ell} @varii{ell}
Like @func{vector-for-each} for two vector arguments, but does not validate its arguments.
@end defun


@defun {$vector-for-each/3} @var{func} @vari{ell} @varii{ell} @variii{ell}
@defunx {$vector-for-each-in-order/3} @var{func} @vari{ell} @varii{ell} @variii{ell}
Like @func{vector-for-each} for three vector arguments, but does not validate its arguments.
@end defun


@defun {$vector-for-each/list} @var{func} @var{list-of-vectors}
@defunx {$vector-for-each-in-order/list} @var{func} @var{list-of-vectors}
Like @func{vector-for-each} for any number vector operands, but does not validate its arguments.
All the vector operands must be in the @var{list-of-vectors}.
@end defun

@c page
@node vectors map index
@subsection Vectors mapping with indexes


@defun vector-map-index @var{proc} @vari{vector} @varii{vector} @dots{}
The @var{vector}s must all have the same length.  @var{proc} must accept as many arguments as there
are @var{vector}s plus one, and return a single value.  @var{proc} must not mutate any of the
@var{vector}s.

The @func{vector-map-index} procedure applies @var{proc} to a fixnum and, element--wise, to the
elements of the @var{vector}s, left to right, and return a vector of the results, in order; the
fixnum argument is the index of the current elements.  @var{proc} is always called in the same
dynamic environment as @func{vector-map-index} itself.  If multiple returns occur from
@func{vector-map-index}, the values returned by earlier returns are not mutated.

@lisp
(vector-map-index
    (lambda (idx item)
      (list idx item))
  '#(a b c))
@result{} #((0 a) (1 b) (2 c))

(vector-map-index
    (lambda (idx item1 item2)
      (list idx item1 item2))
  '#(a b c)
  '#(d e f))
@result{} #((0 a d) (1 b e) (2 c f))
@end lisp
@end defun


@defun vector-for-each-index @var{proc} @vari{vector} @varii{vector} @dots{}
The @var{vector}s must all have the same length.  @var{proc} must accept as many arguments as there
are @var{vector}s plus one.  @var{proc} must not mutate any of the @var{vector}s.

The @func{vector-for-each-index} procedure applies @var{proc} to a fixnum and, element--wise, to the
elements of the @var{vector}s for its side effects, in order from the first elements to the last;
the fixnum argument is the index of the current elements.  @var{proc} is always called in the same
dynamic environment as @func{vector-for-each-index} itself.  The return values of
@func{vector-for-each-index} are unspecified.

@lisp
(let ((v (make-vector 5)))
  (vector-for-each-index
      (lambda (idx item)
        (vector-set! v i (list idx item)))
    '#(a b c d))
  v)
@result{} #((0 a) (1 b) (2 c) (3 d))
@end lisp
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe mapping procedures


@defun {$vector-map-index/1} @var{func} @var{ell}
Like @func{vector-map-index} for a single vector argument, but does not validate its arguments.
@end defun


@defun {$vector-map-index/2} @var{func} @vari{ell} @varii{ell}
Like @func{vector-map-index} for two vector arguments, but does not validate its arguments.
@end defun


@defun {$vector-map-index/3} @var{func} @vari{ell} @varii{ell} @variii{ell}
Like @func{vector-map-index} for three vector arguments, but does not validate its arguments.
@end defun


@defun {$vector-map-index/list} @var{func} @var{list-of-vectors}
Like @func{vector-map-index} for any number vector operands, but does not validate its arguments.
All the vector operands must be in the @var{list-of-vectors}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe iteration procedures


@defun {$vector-for-each-index/1} @var{func} @var{ell}
Like @func{vector-for-each-index} for a single vector argument, but does not validate its arguments.
@end defun


@defun {$vector-for-each-index/2} @var{func} @vari{ell} @varii{ell}
Like @func{vector-for-each-index} for two vector arguments, but does not validate its arguments.
@end defun


@defun {$vector-for-each-index/3} @var{func} @vari{ell} @varii{ell} @variii{ell}
Like @func{vector-for-each-index} for three vector arguments, but does not validate its arguments.
@end defun


@defun {$vector-for-each-index/list} @var{func} @var{list-of-vectors}
Like @func{vector-for-each-index} for any number vector operands, but does not validate its
arguments.  All the vector operands must be in the @var{list-of-vectors}.
@end defun

@c page
@node vectors search
@section Searching vectors


@defun vector-find @var{proc} @var{vector}
@var{proc} must accept one argument and return a single value.  @var{proc} must not mutate
@var{vector}.  The @func{vector-find} procedure applies @var{proc} to the elements of @var{vector}
in order.  If @var{proc} returns a true value for an element, @func{vector-find} immediately returns
that element.  If @var{proc} returns @false{} for all elements of the vector, @func{vector-find}
returns @false{}.  @var{proc} is always called in the same dynamic environment as @func{vector-find}
itself.

@lisp
(vector-find even? '#(3 1 4 1 5 9))
@result{} 4

(vector-find even? '#(3 1 5 1 5 9))
@result{} #f
@end lisp
@end defun


@defun vector-for-all @var{proc} @vari{vector} @varii{vector} @dots{} @varn{vector}
The @var{vector}s must all have the same length, and @var{proc} must accept @math{n} arguments and
return a single value.  @var{proc} must not mutate the @var{vector} arguments.

For natural numbers @math{i = 0, 1, @dots{}}, the @func{vector-for-all} procedure successively
applies @var{proc} to arguments @math{x_i^1 @dots{} x_i^n}, where @math{x_i^j} is the @math{i}-th
element of @varj{vector}, until @false{} is returned.

If @var{proc} returns true values for all but the last elements of the @var{vector} arguments:
@func{vector-for-all} performs a tail call of @var{proc} on the elements @math{k-1}, where @math{k}
is the length of the vectors.  If @var{proc} returns @false{} on any set of elements,
@func{vector-for-all} returns @false{} after the first such application of @var{proc}.  If the
@var{vector}s are all empty, @func{vector-for-all} returns @true{}.

@var{proc} is always called in the same dynamic environment as @func{vector-for-all} itself.

@lisp
(vector-for-all even? '#(3 1 4 1 5 9))
@result{} #f

(vector-for-all even? '#(2 4 14))
@result{} #t

(vector-for-all
    (lambda (n)
      (and (even? n) n))
  '#(2 4 14))
@result{} 14

(vector-for-all < '#(1 2 3) '#(2 3 4))
@result{} #t

(vector-for-all < '#(1 2 4) '#(2 3 4))
@result{} #f
@end lisp
@end defun


@defun vector-exists @var{proc} @vari{vector} @varii{vector} @dots{} @varn{vector}
The @var{vector}s must all have the same length, and @var{proc} must accept @math{n} arguments and
return a single value.  @var{proc} must not mutate the @var{vector} arguments.

For natural numbers @math{i = 0, 1, @dots{}}, the @func{vector-exists} procedure applies @var{proc}
successively to arguments @math{x_i^1 @dots{} x_i^n}, where @math{x_i^j} is the @math{i}-th element
of @varj{vector}, until a true value is returned.

If @var{proc} returns @false{} for all but the last elements of the @var{vector} arguments,
@func{vector-exists} performs a tail call of @var{proc} on the elements @math{k-1}, where @math{k}
is the length of the vectors.  If @var{proc} returns a true value on any set of elements,
@func{vector-exists} returns that value after the first such application of @var{proc}.  If the
@var{vector}s are all empty, @func{vector-exists} returns @false{}.

@var{proc} is always called in the same dynamic environment as @func{vector-exists} itself.

@lisp
(vector-exists even? '#(3 1 4 1 5 9))
@result{} #t

(vector-exists even? '#(3 1 1 5 9))
@result{} #f

(vector-exists
    (lambda (n)
      (and (even? n) n))
  '#(2 1 4 14))
@result{} 2

(vector-exists < '#(1 2 4) '#(2 3 4))
@result{} #t

(vector-exists > '#(1 2 3) '#(2 3 4))
@result{} #f
@end lisp
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe finding


@defun {$vector-find} @var{pred} @var{vec}
Like @func{vector-find}, but does not validate its arguments.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe searching ``for all'' procedures


@defun {$vector-for-all/1} @var{pred} @var{vec}
Like @func{vector-for-all} for a single vector argument, but does not validate its arguments.
@end defun


@defun {$vector-for-all/2} @var{pred} @vari{vec} @varii{vec}
Like @func{vector-for-all} for two vector arguments, but does not validate its arguments.
@end defun


@defun {$vector-for-all/3} @var{pred} @vari{vec} @varii{vec} @variii{vec}
Like @func{vector-for-all} for three vector arguments, but does not validate its arguments.
@end defun


@defun {$vector-for-all/list} @var{pred} @var{list-of-vectors}
Like @func{vector-for-all} for any number vector operands, but does not validate its arguments.  All
the vector operands must be in the @var{list-of-vectors}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe searching ``exists'' procedures


@defun {$vector-exists/1} @var{pred} @var{vec}
Like @func{vector-exists} for a single vector argument, but does not validate its arguments.
@end defun


@defun {$vector-exists/2} @var{pred} @vari{vec} @varii{vec}
Like @func{vector-exists} for two vector arguments, but does not validate its arguments.
@end defun


@defun {$vector-exists/3} @var{pred} @vari{vec} @varii{vec} @variii{vec}
Like @func{vector-exists} for three vector arguments, but does not validate its arguments.
@end defun


@defun {$vector-exists/list} @var{pred} @var{list-of-vectors}
Like @func{vector-exists} for any number vector operands, but does not validate its arguments.  All
the vector operands must be in the @var{list-of-vectors}.
@end defun

@c page
@node vectors copy
@section Copying vectors


@defun vector-copy @var{dst.vec} @var{dst.start} @var{src.vec} @var{src.start} @var{src.end}
Copy elements from the vector @var{src.vec} to the vector @var{dst.vec}; return @var{dst.vec}
itself.  The elements of @var{src.vec} from index @var{src.start} (included) to index @var{src.end}
(excluded) are copied into @var{dst.vec} starting at index @var{dst.start}.

@lisp
(let ((src.vec    '#(a b c d e))
      (dst.vec    (make-vector 5 #f)))
  (vector-copy dst.vec 0
               src.vec 0 (vector-length src.vec)))
@result{} #(a b c d e)

(let ((src.vec    '#(a b c d e))
      (dst.vec    (make-vector 5 #f)))
  (vector-copy dst.vec 0
               src.vec 3 3))
@result{} #(#f #f #f #f #f)

(let ((src.vec    '#(a b c d e))
      (dst.vec    (make-vector 5 #f)))
  (vector-copy dst.vec 1
               src.vec 1 4))
@result{} #(#f b c d #f)
@end lisp
@end defun


@defun $vector-copy @var{dst.vec} @var{dst.start} @var{src.vec} @var{src.start} @var{src.end}
Like @func{vector-copy}, but it does not validate its arguments.
@end defun

@c page
@node vectors sort
@section Sorted vectors


@defun sorted-vector-binary-search @var{item<} @var{vec} @var{sought}
Return @false{} or a non--negative fixnum representing the index at which @var{sought} is present in
the sorted vector @var{vec}.  The procedure @var{item<} is used to compare the items from @var{vec}
and the object @var{sought}.

@lisp
(sorted-vector-binary-search < '#(0 1 2 3 4 5 6 7 8 9) 3)
@result{} 3

(sorted-vector-binary-search < '#(0 1 2 3 4 5 6 7 8 9) 999)
@result{} #f

(sorted-vector-binary-search symbol<?
   '#(a b c d e f g h i l m) 'd)
@result{} 3
@end lisp
@end defun

@c page
@node vectors conditions
@section Exceptional--condition object--types


@menu
* vectors conditions is empty::   Exceptional condition: @condition{vector-is-empty}.
* vectors conditions diff len::   Exceptional condition: @condition{vectors-are-of-different-length}.
* vectors conditions empty len::  Exceptional condition: @condition{vectors-are-empty-or-of-different-length}.
@end menu

@c page
@node vectors conditions is empty
@subsection Exceptional condition: @condition{vector-is-empty}


@deftp {Condition Object} @acondition{vector-is-empty}
Exceptional--condition object--type representing an invalid empty vector operand: a non--empty proper
vector was expected.
@end deftp


@defun make-vector-is-empty-condition
Build and return a new exceptional--condition object of type @condition{vector-is-empty}.
@end defun


@defun condition-vector-is-empty? @var{obj}
Return @true{} if @var{obj} is an exceptional--condition object of type @condition{vector-is-empty} or
a compound condition object having a component of type @condition{vector-is-empty}; otherwise return
@false{}.
@end defun


@defun raise-exception-vector-is-empty @var{who} @var{obj}
Raise a non--continuable exception with compound condition object having components:
@condition{vector-is-empty}; @condition{who}; @condition{message}; @condition{irritants}.
@end defun

@c page
@node vectors conditions diff len
@subsection Exceptional condition: @condition{vectors-are-of-different-length}


@deftp {Condition Object} @acondition{vectors-are-of-different-length}
Exceptional--condition object--type representing invalid vector operands: a proper vectors with the same
length were expected.
@end deftp


@defun make-vectors-are-of-different-length-condition
Build and return a new exceptional--condition object of type
@condition{vectors-are-of-different-length}.
@end defun


@defun condition-vectors-are-of-different-length? @var{obj}
Return @true{} if @var{obj} is an exceptional--condition object of type
@condition{vectors-are-of-different-length} or a compound condition object having a component of type
@condition{vectors-are-of-different-length}; otherwise return @false{}.
@end defun


@defun raise-exception-vectors-are-of-different-length @var{who} @var{obj}
Raise a non--continuable exception with compound condition object having components:
@condition{vectors-are-of-different-length}; @condition{who}; @condition{message};
@condition{irritants}.
@end defun

@c page
@node vectors conditions empty len
@subsection Exceptional condition: @condition{vectors-are-empty-or-of-different-length}


@deftp {Condition Object} @acondition{vectors-are-empty-or-of-different-length}
Exceptional--condition object--type representing invalid vector operands: a proper vectors with the same
length were expected.
@end deftp


@defun make-vectors-are-empty-or-of-different-length-condition
Build and return a new exceptional--condition object of type
@condition{vectors-are-empty-or-of-different-length}.
@end defun


@defun condition-vectors-are-empty-or-of-different-length? @var{obj}
Return @true{} if @var{obj} is an exceptional--condition object of type
@condition{vectors-are-empty-or-of-different-length} or a compound condition object having a component of type
@condition{vectors-are-empty-or-of-different-length}; otherwise return @false{}.
@end defun


@defun raise-exception-vectors-are-empty-or-of-different-length @var{who} @var{obj}
Raise a non--continuable exception with compound condition object having components:
@condition{vectors-are-empty-or-of-different-length}; @condition{who}; @condition{message};
@condition{irritants}.
@end defun

@c page
@node strings
@chapter String functions


@menu
* strings unsafe::              Unsafe operations on strings.
@end menu

@c page
@node strings unsafe
@section Unsafe operations on strings


@deffn {Unsafe Operation} $string-length @var{str}
The argument @var{str} must be a string object.  Return a non--negative fixnum representing the
length of the string @var{str}.
@end deffn

@c page
@node parameters
@chapter Parameter functions and syntaxes


The library @library{mmck lang} reexports from @library{chicken base} some syntactic bindings
forming the parameters @api{}, @ChickenCoreRef{base parms, Parameters}.


@deffn Syntax parameterize ((@qvar{param} @qvar{param-expr}) @dots{}) @qvaro{expr} @qvar{expr} @dots{}
@deffnx Syntax parameterise ((@qvar{param} @qvar{param-expr}) @dots{}) @qvaro{expr} @qvar{expr} @dots{}
The syntactic binding @syntax{parameterize} is reexported from @library{chicken base}.  The
syntactic binding @syntax{parameterise} is an alias for @syntax{parameterize}.
@end deffn


@defun make-parameter @var{obj}
@defunx make-parameter @var{obj} @var{guard}
Build a new parameter.  It is reexported from @library{chicken base}.
@end defun

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
@chicken{} can be downloaded from:

@center @url{http://www.call-cc.org/}

@noindent
the package @mmck{} Lang is available from:

@center @url{https://github.com/marcomaggi/mmck-lang/}

@noindent
the package @mmck{} Checks is available from:

@center @url{https://github.com/marcomaggi/mmck-checks/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function

@printindex fn

@node variable index
@appendix An entry for each variable

@printindex vr

@node type index
@appendix An entry for each type

@printindex tp

@contents
@bye

@c end of file
@c Local Variables:
@c ispell-local-dictionary: "en_GB-ise-w_accents"
@c end:
