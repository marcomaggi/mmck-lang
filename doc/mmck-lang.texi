\input texinfo.tex
@c %**start of header
@setfilename mmck-lang.info
@settitle @sc{mmck} Lang
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      Language extensions for @sc{chicken}

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    @sc{mmck} Lang

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmck-lang

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2019

@set CHICKEN_VERSION            5.1.0

@c ------------------------------------------------------------

@set PackageStem                lang

@set PackageAutoconfPrefix      MMCK_LANG
@set PackagePkgconfigModule     mmck-lang

@set GithubUrl                  @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl                @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl           @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@macro mmck{}
@sc{mmck}
@end macro

@macro chicken{}
@sc{chicken}
@end macro

@c ------------------------------------------------------------------------

@macro ChickenCoreRef{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,chicken-core}
@end macro

@macro ChickenInternalsRef{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,chicken-internals}
@end macro

@macro MMCKExceptionalConditionsRef{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,mmck-exceptional-conditions}
@end macro

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a @chicken{} language package
implementing a extensions to the language.  @chicken{} is a Scheme--to--C compiler supporting the
language features as defined in the ``Revised^5 Report on Scheme''.

The library supports @posix{} platforms.  This package has been tested with @chicken{} version
@value{CHICKEN_VERSION}.

This package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} Lesser
General Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mmck-lang: (mmck-lang).   A lang library for @chicken{}.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* debug::                       Basic debugging facilities.
* binding::                     Binding syntaxes.
* expr::                        Expression syntaxes.
* booleans::                    Boolean functions.
* lists::                       List functions.
* vectors::                     Vector functions.
* strings::                     String functions.
* parameters::                  Parameter functions and syntaxes.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


@cindex @library{mmck lang}, library
@cindex Library @library{mmck lang}


This document describes version @value{VERSION} of @value{PACKAGE}, a @chicken{} language package
implementing extensions to the language.  @chicken{} is a Scheme-to-C compiler supporting the
language features as defined in the ``Revised^5 Report on Scheme''.

This package supports @posix{} platforms.  This package depends upon the @chicken{} egg
@code{matchable}.  This package depends upon the external packages: @mmck{} Exceptional Conditions.
To run the tests distributed with the source code: this package depends upon the package @mmck{}
Checks.

The package installs the library @library{mmck lang} along with its import library.  To require the
library and import its syntactic bindings in a module we can do:

@example
(declare (unit my-module)
         (emit-import-library my-module))

(require-library (mmck lang))

(module (my-module)
    ()
  (import (scheme)
          (mmck lang))

  ...

  #| end of module |# )
@end example

@c page
@node version
@chapter Version functions


@value{PACKAGE}'s version number follows the specification of @dfn{Semantic Versioning} version 2.0
as outlined at:

@center @url{https://semver.org/}

@noindent
the following functions are available to inspect the version specification at runtime.


@defun mmck-@value{PackageStem}-package-major-version
Return a fixnum representing the package's major version number.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the major version number is the fixnum @samp{1}.
@end defun


@defun mmck-@value{PackageStem}-package-minor-version
Return a fixnum representing the package's minor version number.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the minor version number is the fixnum @samp{2}.
@end defun


@defun mmck-@value{PackageStem}-package-patch-level
Return a fixnum representing the package's patch level number.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the patch level number is the fixnum @samp{3}.
@end defun


@defun mmck-@value{PackageStem}-package-prerelease-tag
Return a string representing the package's prerelease tag.  As example, if the full semantic version
is @samp{1.2.3-devel.0+x86-64}: the prerelease tag is the string @samp{"devel.0"}.  This string may
be empty.
@end defun


@defun mmck-@value{PackageStem}-package-build-metadata
Return a string representing the package's build metadata.  As example, if the full semantic version
is @samp{1.2.3-devel.0+x86-64}: the build metadata is the string @samp{"x86-64"}.  This string may
be empty.  We need to remember that this specification segment must contain only @ascii{}
alphanumerics and hyphen @samp{[0-9A-Za-z-]}; underscores are @strong{not} allowed.
@end defun


@defun mmck-@value{PackageStem}-package-version
Return a string representing the package's version.  As example, if the full semantic version is
@samp{1.2.3-devel.0+x86-64}: the package version is the string @samp{"1.2.3-devel.0"}, without the
build metadata.
@end defun


@defun mmck-@value{PackageStem}-package-semantic-version
Return a string representing the package's semantic version.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the package version is the string
@samp{"v1.2.3-devel.0+x86-64"}, notice the leading character @samp{v}.
@end defun

@c page
@node debug
@chapter Basic debugging facilities


@defun debug-print @var{obj} @dots{}
Gather all the @var{obj} values in a list and print it the value of @code{(current-error-port)},
followed by a newline character.
@end defun

@c page
@node binding
@chapter Binding syntaxes


@menu
* binding reexports::           Reexported syntactic bindings.
* binding vars::                Defining syntactic bindings for variables.
* binding syns::                Defining syntactic bindings for syntaxes.
@end menu

@c page
@node binding reexports
@section Reexported syntactic bindings


@cindex Reexported syntactic bindings
@findex @syntax{case-lambda}, reexported syntactic binding
@findex @syntax{receive}, reexported syntactic binding


The library @library{mmck lang} reexports the following syntactic bindings from @library{chicken
base}:

@lisp
case-lambda
receive
@end lisp

@c page
@node binding vars
@section Defining syntactic bindings for variables


@menu
* binding vars define*::             The syntax @syntax{define*}.
* binding vars case-define::         The syntax @syntax{case-define}.
* binding vars case-define*::        The syntax @syntax{case-define*}.
* binding vars receive-and-return::  The syntax @syntax{receive-and-return}.
@end menu

@c page
@node binding vars define*
@subsection The syntax @syntax{define*}


@cindex @syntax{__who__}, defined by @syntax{define*}


@deffn Syntax {define*} (@qvar{who} . @qvar{formals}) @qvaro{body} @qvar{body} @dots{}
@deffnx Syntax {define*} @qvar{who} @qvar{expr}
Similar to @syntax{define}.  Inject the unhygienic syntax @syntax{__who__} whose uses expand into
@code{(quote @qvar{who})} so that its region of visibility is the defined expression.  The first
form expands into something like:

@lisp
(define @qvar{who}
  (lambda @qvar{formals})
    (let-syntax ((__who__ (syntax-rules ()
                            ((_)
                             (quote @qvar{who})))))
      @qvaro{body} @qvar{body} @dots{}))
@end lisp

@noindent
the second form expands into something like:

@lisp
(define @qvar{who}
  (let-syntax ((__who__ (syntax-rules ()
                          ((_)
                           (quote @qvar{who})))))
    @qvar{expr}))
@end lisp
@end deffn


Let's see some basic usage examples:

@lisp
(begin
  (define* (doit1 a b)
    (list __who__ a b))

  (doit1 'A 'B))
@result{} (doit1 A B)

(begin
  (define* (doit2 a b . rest)
    (list (__who__) a b rest))

  (doit2 'A 'B 'C 'D 'E))
@result{} (doit2 A B (C D E))

(begin
  (define* (doit . args)
    (list (__who__) args))

  (doit 'A 'B 'C 'D 'E))
@result{} (doit (A B C D E))

(define* it
  (list (__who__) 1 2))

it      @result{} (it 1 2)
@end lisp

Now let's see how to build and raise an exceptional--condition object, as defined by
@library{chicken condition}, with @code{location} property:

@lisp
(import (scheme)
        (mmck lang)
        (prefix (chicken condition) chicken::))

(define* (raise-it)
  (chicken::abort
   (chicken::make-property-condition 'mine 'location (__who__))))

(chicken::condition-case
    (raise-it)
  (E (mine)
     (chicken::get-condition-property E 'mine 'location))
  (() #f))
@result{} raise-it
@end lisp

Now let's see how to build and raise an exceptional--condition object, as defined by @library{mmck
exceptional-conditions}, with a @condition{who} component:

@lisp
(import (scheme)
        (mmck lang)
        (mmck exceptional-conditions))

(define* (raise-it)
  (raise
   (condition (make-error)
              (make-who-condition (__who__)))))

(guard (E ((error? E)
           (condition-who E))
          (else #f))
  (raise-it))
@result{} raise-it
@end lisp

@c page
@node binding vars case-define
@subsection The syntax @syntax{case-define}


@deffn Syntax case-define @qvar{who} (@qvar{formals} @qvaro{body} @qvar{body} @dots{}) @dots{}
Define a function accepting multiple formals specifications.  Inject the unhygienic syntax
@syntax{__who__} whose uses expand into @code{(quote @qvar{who})} so that its region of visibility
is the defined expression.  Expands into:

@lisp
(define @qvar{who}
  (case-lambda
    (@qvar{formals} @qvaro{body} @qvar{body} @dots{})
    @dots{}))
@end lisp

@noindent
where @syntax{case-lambda} is the syntax exported by @library{chicken base}.
@end deffn


Usage examples:

@lisp
(case-define doit
  (()                   0)
  ((a)                  (list 1 a))
  ((a b)                (list 2 a b))
  ((a b c . rest)       (list '* a b c rest)))

(doit)                  @result{} 0
(doit 'A)               @result{} (1 A)
(doit 'A 'B)            @result{} (2 A B)
(doit 'A 'B 'C 'D 'E)   @result{} (* A B C (D E))
@end lisp

@c page
@node binding vars case-define*
@subsection The syntax @syntax{case-define*}


@cindex @syntax{__who__}, defined by @syntax{case-define*}


@deffn Syntax case-define* @qvar{who} (@qvar{formals} @qvaro{body} @qvar{body} @dots{}) @dots{}
Define a function accepting multiple formals specifications.  Expands to:

@lisp
(define @qvar{who}
  (case-lambda
    (@qvar{formals}
     (let-syntax ((__who__ (syntax-rules ()
                             ((_)
                              (quote @qvar{who})))))
       @qvaro{body} @qvar{body} @dots{}))
    @dots{}))
@end lisp

@noindent
where @syntax{case-lambda} is the syntax exported by @library{chicken base}.
@end deffn


Usage examples:

@lisp
(case-define* doit
  (()                   (list (__who__) 0))
  ((a)                  (list (__who__) 1 a))
  ((a b)                (list (__who__) 2 a b))
  ((a b c . rest)       (list (__who__) '* a b c rest)))

(doit)                  @result{} (doit 0)
(doit 'A)               @result{} (doit 1 A)
(doit 'A 'B)            @result{} (doit 2 A B)
(doit 'A 'B 'C 'D 'E)   @result{} (doit * A B C (D E))
@end lisp

@c page
@node binding vars receive-and-return
@subsection The syntax @syntax{receive-and-return}


@deffn Syntax receive-and-return @qvar{formals} @qvar{expr} @qvaro{body} @qvar{body} @dots{}
Evaluate @qvar{expr} and bind its return values to @qvar{formals}, as if @syntax{let-values} was
used; then, in the region of visibility of the formals, evaluate the @qvar{body} expressions.
Finally, return the values bound to the formals.
@end deffn


Usage examples:

@lisp
(receive-and-return (a)
    (list 1 2)
  (pretty-print a))
@result{} (1 2)
@print{} (1 2)

(receive-and-return (a b)
    (values 1 2)
  (pretty-print a))
@result{} 1 2
@print{} 1

(receive-and-return ()
    (values)
  (pretty-print 3))
@result{} #<unspecified>
@print{} 3
@end lisp

@c page
@node binding syns
@section Defining syntactic bindings for syntaxes


@menu
* binding syns define-syntax-rule::         The syntax @syntax{define-syntax-rule}.
* binding syns define-auxiliary-syntaxes::  The syntax @syntax{define-auxiliary-syntaxes}.
* binding syns auxiliary::                  Auxiliary syntaxes.
@end menu

@c page
@node binding syns define-syntax-rule
@subsection The syntax @syntax{define-syntax-rule}


@deffn Syntax define-syntax-rule (@qvar{name} . @qvar{formals}) @qvaro{expr} @qvar{expr} @dots{}
Define a macro with a single @syntax{syntax-rules} rule.  Expands to:

@lisp
(define-syntax @qvar{name}
  (syntax-rules ()
    ((_ . @qvar{formals})
     (begin @qvaro{expr} @qvar{expr} @dots{}))))
@end lisp
@end deffn


Usage examples:

@lisp
(internal-body
  (define-syntax-rule (doit a b)
    (list a b))

  (doit 1 2))
@result{} (1 2)

(internal-body
  (define-syntax-rule (doit)
    (list 1 2))

  (doit))
@result{} (1 2)

(internal-body
  (define-syntax-rule (doit ?a ?b . ?rest)
    (vector '?a '?b '?rest))

  (doit 1 2 3 4))
@result{} #(1 2 (3 4))
@end lisp

@c page
@node binding syns define-auxiliary-syntaxes
@subsection The syntax @syntax{define-auxiliary-syntaxes}


@deffn Syntax define-auxiliary-syntaxes @qvaro{name} @qvar{name} @dots{}
For each of the @qvar{name} define a syntax like:

@lisp
(define-syntax @qvar{name} (syntax-rules ()))
@end lisp

This is useful to define auxiliary syntaxes like the @syntax{else} used by the standard
@syntax{cond}.
@end deffn


Let's see how to use it with @syntax{syntax-rules}:

@lisp
(define-auxiliary-syntaxes ciao)

(define-syntax doit
  (syntax-rules (ciao)
    ((_ ciao)
     #t)
    ((_ ?thing)
     #f)))

(doit ciao)     @result{} #t
(doit hello)    @result{} #f
@end lisp

@noindent
now with @func{er-macro-transformer} and @func{match} from the @library{matchable} egg:

@lisp
(import-for-syntax (scheme)
                   (only (chicken syntax)
                         er-macro-transformer)
                   (only (matchable)
                         match))

(define-auxiliary-syntaxes ciao)

(define-syntax doit
  (er-macro-transformer
    (lambda (input-form.stx rename compare)
      (define %ciao (rename 'ciao))
      (define (ciao? obj)
        (compare %ciao obj))
      (match input-form.stx
        ((_ (? ciao?))
         #t)
        (_
         #f)))))

(doit ciao)     @result{} #t
(doit hello)    @result{} #f
@end lisp

@noindent
now with @func{ir-macro-transformer} and @func{match} from the @library{matchable} egg:

@lisp
(import-for-syntax (scheme)
                   (only (chicken syntax)
                         er-macro-transformer)
                   (only (matchable)
                         match))

(define-auxiliary-syntaxes ciao)

(define-syntax doit
  (ir-macro-transformer
    (lambda (input-form.stx inject compare)
      (define %ciao (inject 'ciao))
      (define (ciao? obj)
        (compare %ciao obj))
      (match input-form.stx
        ((_ (? ciao?))
         #t)
        (_
         #f)))))

(doit ciao)     @result{} #t
(doit hello)    @result{} #f
@end lisp

@c page
@node binding syns auxiliary
@subsection Auxiliary syntaxes


@deffn {Auxiliary Syntax} __who__
Defined in the expression/body of syntaxes like @syntax{define*}, @syntax{case-define*},
@syntax{named-lambda}.  It expands to the quoted name of the object being defined.

We can use the syntax @syntax{__who__} as value for the condition property @code{location}
(@ChickenCoreRef{condition srfi-12 condition, Condition objects}), or as value for the
@condition{who} condition object (@MMCKExceptionalConditionsRef{conditions types r6rs, Predefined
condition types compatible with @rnrs{6}}).
@end deffn

@c page
@node expr
@chapter Expression syntaxes


@menu
* expr named-lambda::           The syntax @syntax{named-lambda}.
* expr misc::                   Miscellaneous expression syntaxes.
* expr reexports::              Reexported syntactic bindings.
@end menu

@c page
@node expr named-lambda
@section The syntax @syntax{named-lambda}


@deffn Syntax named-lambda @qvar{who} @qvar{formals} @qvaro{body} @qvar{body} @dots{}
Similar to @syntax{lambda}.  Inject the unhygienic syntax @syntax{__who__} whose uses expand into
@code{(quote @qvar{who})} so that its region of visibility is the function body.  Expand into
something like:

@lisp
(lambda @qvar{formals}
  (let-syntax ((__who__ (syntax-rules ()
                          ((_)
                           (quote @qvar{who})))))
    @qvaro{body} @qvar{body} @dots{}))
@end lisp

We can use the variable @code{__who__} as value for the condition property @code{location}, or as
value for the @condition{who} condition object.
@end deffn


Usage examples:

@lisp
(define func
  (named-lambda the-func (a b)
    (list (__who__) a b)))

(func 1 2)      @result{} (the-func 1 2)
@end lisp

@c page
@node expr misc
@section Miscellaneous expression syntaxes


@deffn Syntax alist-var-cons! @qvar{alist-var} @qvar{key} @qvar{val}
Push a new entry into an association list.  Expand into:

@lisp
(set! @qvar{alist-var} (cons (cons @qvar{key} @qvar{val}) @qvar{alist-var}))
@end lisp
@end deffn


@deffn Syntax internal-body @qvaro{body} @qvar{body} @dots{}
Expand into:

@lisp
(let () @qvaro{body} @qvar{body} @dots{})
@end lisp
@end deffn


@deffn Syntax begin0 @qvar{expr} @qvaro{body} @qvar{body} @dots{}
Evaluate @qvar{expr} and save its return values; evaluate the @qvar{body} forms; finally return the
values returned by @qvar{expr}.

@lisp
(begin0
    (+ 1 2)
  (pretty-print 'here))
@result{} 3
@print{} here
@end lisp
@end deffn


@deffn Syntax begin-checks @qvaro{expr} @qvar{expr} @dots{}
Like @syntax{begin}, but wrap the whole form into the @chicken{} low--level operation
@syntax{##core#check}, so that: if unsafe compilation is enabled, the whole form expands to
no--operations.  @ChickenInternalsRef{checks unsafe, Including/excluding checks}.
@end deffn


@deffn Syntax xor @qvar{expr} @dots{}
Exclusive OR.
@end deffn

@c page
@node expr reexports
@section Reexported syntactic bindings


@cindex Reexported syntactic bindings
@findex @syntax{when}, reexported syntactic binding
@findex @syntax{unless}, reexported syntactic binding


The library @library{mmck lang} reexports the following syntactic bindings from @library{chicken
base}:

@lisp
when
unless
@end lisp

@c page
@node booleans
@chapter Boolean functions


@deffn Syntax boolean-true? @qvar{obj}
@deffnx Syntax boolean-false? @qvar{obj}
Predicates for the boolean objects @true{} and @false{}.
@end deffn

@c page
@node lists
@chapter List functions


The lists @api{} implemented by @value{PACKAGE} is inspired by that defined by @rnrs{6}; but there
are important differences.  Notice that:

@itemize
@item
The functions @strong{do not} check for circular lists.  If a list argument is circular: the
behaviour is undefined.

@item
The functions check their list arguments at the beginning, traversing the whole lists.  This
consumes resources.
@end itemize

@menu
* lists unsafe::                Basic unsafe list operations.
* lists cons::                  List constructors.
* lists pred::                  List predicates.
* lists getters::               Special list getters.
* lists fold::                  Folding lists.
* lists map::                   Mapping lists.
* lists search::                Searching lists.
@end menu

@c page
@node lists unsafe
@section Basic unsafe list operations


@deffn {Unsafe Operation} $car @var{pair}
Like @func{car} but the operation is integrated at the call site and it does not check its
arguments.
@end deffn


@deffn {Unsafe Operation} $cdr @var{pair}
Like @func{cdr} but the operation is integrated at the call site and it does not check its
arguments.
@end deffn


@deffn {Unsafe Operation} $set-car! @var{pair} @var{new-value}
Like @func{set-car!} but the operation is integrated at the call site and it does not check its
arguments.
@end deffn


@deffn {Unsafe Operation} $set-cdr! @var{pair} @var{new-value}
Like @func{set-cdr!} but the operation is integrated at the call site and it does not check its
arguments.
@end deffn


@deffn {Unsafe Operation} $set-car-immediate! @var{pair} @var{new-value}
Like @func{set-car!} but the operation is integrated at the call site, it does not check its
arguments, and @var{new-value} must be an immediate value.
@end deffn


@deffn {Unsafe Operation} $set-cdr-immediate! @var{pair} @var{new-value}
Like @func{set-cdr!} but the operation is integrated at the call site, it does not check its
arguments, and @var{new-value} must be an immediate value.
@end deffn

@c page
@node lists cons
@section List constructors


@defun cons* @var{obj} @dots{} @var{tail}
Build and return a new list having the @var{obj} as first values and @var{tail} as tail.

@lisp
(cons* 1 '())           @result{} (1)
(cons* 1 2 '())         @result{} (1 2)
(cons* 1 2 3 '())       @result{} (1 2 3)

(cons* 1 '(2 3))        @result{} (1 2 3)
(cons* 1 2 3 '(4 5))    @result{} (1 2 3 4 5)
@end lisp
@end defun


@defun make-list @var{len}
@defunx make-list @var{len} @var{fill}
Build and return a new list of @var{len} pairs.  If @var{fill} is given: the cars of the pairs are
set to @var{fill}; @var{fill} defaults to the return value of @code{(void)}, where @func{void} is
the syntactic binding exported by @library{chicken base}.

@lisp
(make-list 0 'a)        @result{} ()
(make-list 3 'a)        @result{} (a a a)

(equal? (make-list 3)
        (list (void) (void) (void)))
@result{} #t
@end lisp
@end defun

@c page
@node lists pred
@section List predicates


@defun list-of-lists? @var{obj}
Return @true{} if @var{obj} is a (possibly empty) list of (possibly empty) lists; otherwise return
@false{}.  Notice that this function returns null if @var{obj} is neither null nor a proper list of
pairs.

@lisp
(list-of-lists? '())            @result{} #t
(list-of-lists? '(()))          @result{} #t
(list-of-lists? '(() ()))       @result{} #t
(list-of-lists? '(() () ()))    @result{} #t
(list-of-lists? '((1)))         @result{} #t
(list-of-lists? '((1) (2)))     @result{} #t
(list-of-lists? '((1) (2) (3))) @result{} #t

(list-of-lists? '(1 (2) (3)))   @result{} #f
(list-of-lists? '((1) 2 (3)))   @result{} #f
(list-of-lists? '((1) (2) 3))   @result{} #f

(list-of-lists? '#())           @result{} #f
@end lisp
@end defun


@defun list-of-nulls? @var{obj}
Return @true{} if @var{obj} is a (possibly empty) list of null objects; otherwise return @false{}.
Notice that this function returns @false{} if @var{obj} is neither null nor a proper list of nulls.

@lisp
(list-of-nulls? '())            @result{} #t
(list-of-nulls? '(()))          @result{} #t
(list-of-nulls? '(() ()))       @result{} #t
(list-of-nulls? '(() () ()))    @result{} #t

(list-of-nulls? '((1)))         @result{} #f
(list-of-nulls? '((1) (2)))     @result{} #f
(list-of-nulls? '((1) (2) (3))) @result{} #f

(list-of-nulls? '(1 (2) (3)))   @result{} #f
(list-of-nulls? '((1) 2 (3)))   @result{} #f
(list-of-nulls? '((1) (2) 3))   @result{} #f

(list-of-nulls? '#())           @result{} #f
@end lisp
@end defun


@defun list-of-pairs? @var{obj}
Return @true{} if @var{obj} is a (possibly empty) list of pair objects; otherwise return @false{}.
Notice that this function returns @false{} if @var{obj} is neither null nor a proper list of pairs.

@lisp
(list-of-pairs? '())            @result{} #t
(list-of-pairs? '((1)))         @result{} #t
(list-of-pairs? '((1) (2)))     @result{} #t
(list-of-pairs? '((1) (2) (3))) @result{} #t

(list-of-pairs? '(()))          @result{} #f
(list-of-pairs? '(() ()))       @result{} #f
(list-of-pairs? '(() () ()))    @result{} #f

(list-of-pairs? '(1 (2) (3)))   @result{} #f
(list-of-pairs? '((1) 2 (3)))   @result{} #f
(list-of-pairs? '((1) (2) 3))   @result{} #f

(list-of-pairs? '#())           @result{} #f
@end lisp
@end defun


@defun lists-of-lists-of-equal-length? @var{obj}
Return @true{} if @var{obj} is a (possibly empty) list of (possibly empty) lists of equal length;
otherwise return @false{}.  Notice that this function returns @false{} if @var{obj} is neither null
nor a proper list of pairs.

@lisp
(lists-of-lists-of-equal-length? '())                   @result{} #t
(lists-of-lists-of-equal-length? '(()))                 @result{} #t
(lists-of-lists-of-equal-length? '(() ()))              @result{} #t
(lists-of-lists-of-equal-length? '(() () ()))           @result{} #t
(lists-of-lists-of-equal-length? '((1)))                @result{} #t
(lists-of-lists-of-equal-length? '((1) (2)))            @result{} #t
(lists-of-lists-of-equal-length? '((1) (2) (3)))        @result{} #t

(lists-of-lists-of-equal-length? '(() (2) (3)))         @result{} #f
(lists-of-lists-of-equal-length? '((1) () (3)))         @result{} #f
(lists-of-lists-of-equal-length? '((1) (2) ()))         @result{} #f
(lists-of-lists-of-equal-length? '((1 0) (2) (3)))      @result{} #f
(lists-of-lists-of-equal-length? '((1) (2 0) (3)))      @result{} #f
(lists-of-lists-of-equal-length? '((1) (2) (3 0)))      @result{} #f

(lists-of-lists-of-equal-length? '((1 2 3 4 5)))        @result{} #t
(lists-of-lists-of-equal-length? '((1 2 3 4 5)
                                   (6 7 8 9 0)))        @result{} #t
(lists-of-lists-of-equal-length? '((1 2 3 4 5)
                                   (6 7 8 9 0)
                                   (9 8 7 6 5)))        @result{} #t

(lists-of-lists-of-equal-length? 123)                   @result{} #f
@end lisp
@end defun


@defun lists-of-equal-length? @varo{obj} @var{obj} @dots{}
Return @true{} if all the arguments are (possibly empty) lists of equal length; otherwise return
@false{}.  Notice that this function returns @false{} if one of the arguments is neither null nor a
proper list of pairs.

@lisp
(lists-of-equal-length? '())                    @result{} #t
(lists-of-equal-length? '() '())                @result{} #t
(lists-of-equal-length? '() '() '())            @result{} #t
(lists-of-equal-length? '(1))                   @result{} #t
(lists-of-equal-length? '(1) '(2))              @result{} #t
(lists-of-equal-length? '(1) '(2) '(3))         @result{} #t

(lists-of-equal-length? '() '(2) '(3))          @result{} #f
(lists-of-equal-length? '(1) '() '(3))          @result{} #f
(lists-of-equal-length? '(1) '(2) '())          @result{} #f
(lists-of-equal-length? '(1 0) '(2) '(3))       @result{} #f
(lists-of-equal-length? '(1) '(2 0) '(3))       @result{} #f
(lists-of-equal-length? '(1) '(2) '(3 0))       @result{} #f

(lists-of-equal-length? '(1 2 3 4 5))           @result{} #t
(lists-of-equal-length? '(1 2 3 4 5)
                        '(6 7 8 9 0))           @result{} #t
(lists-of-equal-length? '(1 2 3 4 5)
                        '(6 7 8 9 0)
                        '(9 8 7 6 5))           @result{} #t

(lists-of-equal-length? 123)                    @result{} #f
@end lisp
@end defun

@c page
@node lists getters
@section Special list getters


@defun cars-and-cdrs @var{list-of-lists}
@defunx cars-and-cdrs @var{list-of-lists} @var{cars-tail}
The argument @var{list-of-lists} must be a non--empty list of non--empty lists.  Return two values:

@enumerate
@item
A list of the CARs of the lists in @var{list-of-lists}.

@item
A list of the CDRs of the lists in @var{list-of-lists}.
@end enumerate

The optional argument @var{cars-tail} is appended to the cars list; it defaults to null.

@lisp
(cars-and-cdrs '((1 2 3)
                 (4 5 6)))
@result{} (1 4) ((2 3) (5 6))

(cars-and-cdrs '((1 2 3)
                 (4 5 6)
                 (7 8 9)))
@result{} (1 4 7) ((2 3) (5 6) (8 9))

(cars-and-cdrs '((1 2 3)
                 (4 5 6))
               '(a b))
@result{} (1 4 a b) ((2 3) (5 6))

(cars-and-cdrs '((1 2 3)
                 (4 5 6)
                 (7 8 9))
               '(a b))
@result{} (1 4 7 a b) ((2 3) (5 6) (8 9))
@end lisp
@end defun



@defun gather-cars-in-reverse @var{list-of-lists}
@defunx gather-cars-in-reverse @var{list-of-lists} @var{cars-tail}
The argument @var{list-of-lists} must be a (possibly empty) list of (possibly empty) lists.  Return
a list of lists, each sublist being the lists of cars built by iterating through @var{list-of-lists}
from the end.  The optional argument @var{cars-tail} is appended to each cars list; it defaults to
null.

The returned value is the list of lists we would need to implement @func{fold-right}.

@lisp
(gather-cars-in-reverse '())            @result{} ()
(gather-cars-in-reverse '(()))          @result{} ()
(gather-cars-in-reverse '(() ()))       @result{} ()
(gather-cars-in-reverse '(() () ()))    @result{} ()
(gather-cars-in-reverse '((1) (4) (7))) @result{} ((1 4 7))

(gather-cars-in-reverse '((1 2 3)
                          (4 5 6)
                          (7 8 9)))
@result{} ((3 6 9)
    (2 5 8)
    (1 4 7))

(define tail '(a b))

(gather-cars-in-reverse '()            tail) @result{} ()
(gather-cars-in-reverse '(())          tail) @result{} ()
(gather-cars-in-reverse '(() ())       tail) @result{} ()
(gather-cars-in-reverse '(() () ())    tail) @result{} ()
(gather-cars-in-reverse '((1) (4) (7)) tail) @result{} ((1 4 7 a b))

(gather-cars-in-reverse '((1 2 3)
                          (4 5 6)
                          (7 8 9))
                        tail)
@result{} ((3 6 9 a b)
    (2 5 8 a b)
    (1 4 7 a b))
@end lisp
@end defun


@defun butlast-and-last @var{ell}
The argument @var{ell} must be a (possibly empty) proper list.  Return two values:

@enumerate
@item
The list of all the items in @var{ell} but the last.

@item
The last item in @var{ell}.
@end enumerate

@lisp
(butlast-and-last '())               @error{} &list-is-empty
(butlast-and-last '(0))              @result{} () 0
(butlast-and-last '(0 1))            @result{} (0) 1
(butlast-and-last '(0 1 2))          @result{} (0 1) 2
(butlast-and-last '(0 1 2 3))        @result{} (0 1 2) 3
(butlast-and-last '(0 1 2 3 4))      @result{} (0 1 2 3) 4
(butlast-and-last '(0 1 2 3 4 5))    @result{} (0 1 2 3 4) 5
(butlast-and-last '(0 1 2 3 4 5 6))  @result{} (0 1 2 3 4 5) 6
@end lisp
@end defun

@c page
@node lists fold
@section Folding lists


@defun fold-left @var{combine} @var{nil} @vari{list} @varii{list} @dots{} @varn{list}
The @var{list}s must all have the same length.  @var{combine} must be a procedure; it must accept
one more argument than there are @var{list}s and return a single value; it must not mutate the
@var{list} arguments.

The @func{fold-left} procedure iterates the @var{combine} procedure over an accumulator value and
the elements of the @var{list}s from left to right, starting with an accumulator value of @var{nil}.
@var{combine} must have signature:

@lisp
(lambda (nil item0 item ...) . @meta{body})
@end lisp

More specifically, @func{fold-left} returns @var{nil} if the @var{list}s are empty.  If they are not
empty, @var{combine} is first applied to @var{nil} and the respective first elements of the
@var{list}s in order.  The result becomes the new accumulator value, and @var{combine} is applied to
the new accumulator value and the respective next elements of the @var{list}.  This step is repeated
until the end of the list is reached; then the accumulator value is returned.

@var{combine} is always called in the same dynamic environment as @func{fold-left} itself.

@lisp
(fold-left + 0 '(1 2 3 4 5))
@result{} 15

(fold-left
    (lambda (a e)
      (cons e a))
  '()
  '(1 2 3 4 5))
@result{} (5 4 3 2 1)

(fold-left
    (lambda (count x)
      (if (odd? x)
          (+ count 1)
        count))
  0
  '(3 1 4 1 5 9 2 6 5 3))
@result{} 7

(fold-left
    (lambda (max-len s)
      (max max-len (string-length s)))
  0
  '("longest" "long" "longer"))
@result{} 7

(fold-left cons '(q) '(a b c))
@result{} ((((q) . a) . b) . c)

(fold-left + 0 '(1 2 3) '(4 5 6))
@result{} 21
@end lisp
@end defun


@defun fold-right @var{combine} @var{nil} @vari{list} @varii{list} @dots{} @varn{list}
The @var{list}s must all have the same length.  @var{combine} must be a procedure; it must accept
one more argument than there are @var{list}s and return a single value; @var{combine} must not
mutate the @var{list} arguments.

The @func{fold-right} procedure iterates the @var{combine} procedure over the elements of the
@var{list}s from right to left and an accumulator value, starting with an accumulator value of
@var{nil}; @var{combine} must have signature:

@lisp
(lambda (item0 item ... nil) . @meta{body})
@end lisp

More specifically, @func{fold-right} returns @var{nil} if the @var{list}s are empty.  If they are
not empty, @var{combine} is first applied to the respective last elements of the @var{list}s in
order and @var{nil}.  The result becomes the new accumulator value, and @var{combine} is applied to
the respective previous elements of the @var{list}s and the new accumulator value.  This step is
repeated until the beginning of the list is reached; then the accumulator value is returned.

@var{proc} is always called in the same dynamic environment as @func{fold-right} itself.

@lisp
(fold-right + 0 '(1 2 3 4 5))
@result{} 15

(fold-right cons '() '(1 2 3 4 5))
@result{} (1 2 3 4 5)

(fold-right
    (lambda (item knil)
      (cons item knil))
  '()
  '(1 2 3 4))
@result{} (1 2 3 4)

(fold-right
    (lambda (x l)
      (if (odd? x) (cons x l) l))
  '()
  '(3 1 4 1 5 9 2 6 5))
@result{} (3 1 1 5 9 5)

(fold-right cons '(q) '(a b c))
@result{} (a b c q)

(fold-right + 0 '(1 2 3) '(4 5 6))
@result{} 21
@end lisp
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe left--folding procedures


@defun {$fold-left/1} @var{combine} @var{nil} @var{ell}
Like @func{fold-left} for a single list argument, but does not validate its arguments.
@end defun


@defun {$fold-left/2} @var{combine} @var{nil} @vari{ell} @varii{ell}
Like @func{fold-left} for two list arguments, but does not validate its arguments.
@end defun


@defun {$fold-left/3} @var{combine} @var{nil} @vari{ell} @varii{ell} @variii{ell}
Like @func{fold-left} for three list arguments, but does not validate its arguments.
@end defun


@defun {$fold-left/list} @var{combine} @var{nil} @var{list-of-lists}
Like @func{fold-left} for any number list operands, but does not validate its arguments.  All the
list operands must be in the @var{list-of-lists}.

@lisp
($fold-left/list
    (lambda (knil item1 item2 item3 item4)
      (list knil item1 item2 item3 item4))
  0
  '((1 2 3 4)
    (5 6 7 8)
    (9 1 2 3)
    (4 5 6 7)))
@result{} ((((0 1 5 9 4) 2 6 1 5) 3 7 2 6) 4 8 3 7)
@end lisp
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe right--folding procedures


@defun {$fold-right/1} @var{combine} @var{nil} @var{ell}
Like @func{fold-right} for a single list argument, but does not validate its arguments.
@end defun


@defun {$fold-right/2} @var{combine} @var{nil} @vari{ell} @varii{ell}
Like @func{fold-right} for two list arguments, but does not validate its arguments.
@end defun


@defun {$fold-right/3} @var{combine} @var{nil} @vari{ell} @varii{ell} @variii{ell}
Like @func{fold-right} for three list arguments, but does not validate its arguments.
@end defun


@defun {$fold-right/list} @var{combine} @var{nil} @var{list-of-lists}
Like @func{fold-right} for any number list operands, but does not validate its arguments.  All the
list operands must be in the @var{list-of-lists}.

@lisp
($fold-right/list
    (lambda (item1 item2 item3 item4 item5 knil)
      (cons (list item1 item2 item3 item4 item5) knil))
  0
  '((1 2 3 4)
    (5 6 7 8)
    (9 1 2 3)
    (4 5 6 7)
    (a b c d)))
@result{} ((1 5 9 4 a) (2 6 1 5 b) (3 7 2 6 c) (4 8 3 7 d) . 0)
@end lisp
@end defun

@c page
@node lists map
@section Mapping lists

@c page
@node lists search
@section Searching lists


@c page
@node vectors
@chapter Vector functions


@menu
* vectors unsafe::              Unsafe operations on vectors.
@end menu

@c page
@node vectors unsafe
@section Unsafe operations on vectors


@deffn {Unsafe Operation} $vector-length @var{vec}
The argument @var{vec} must be a vector object.  Return a non--negative fixnum representing the
length of the vector @var{vec}.
@end deffn


@deffn {Unsafe Operation} $vector-ref @var{vec} @var{fxidx}
The argument @var{vec} must be a vector object.  The argument @var{fxidx} must be a non--negative
integer representing a valid index in the vector @var{vec}.  Return the object at index @var{fxidx}
in the vector @var{vec}.
@end deffn


@deffn {Unsafe Operation} $vector-set! @var{vec} @var{fxidx} @var{obj}
The argument @var{vec} must be a vector object.  The argument @var{fxidx} must be a non--negative
integer representing a valid index in the vector @var{vec}.  Store the object @var{obj} at index
@var{fxidx} in the vector @var{vec}; return unspecified values.
@end deffn


@deffn {Unsafe Operation} $vector-set-immediate! @var{vec} @var{fxidx} @var{imm-obj}
The argument @var{vec} must be a vector object.  The argument @var{fxidx} must be a non--negative
integer representing a valid index in the vector @var{vec}.  Store the immediate object
@var{imm-obj} at index @var{fxidx} in the vector @var{vec}; return unspecified values.  This
operation is a bit faster than @func{$vector-set!}.
@end deffn


@c page
@node strings
@chapter String functions


@menu
* strings unsafe::              Unsafe operations on strings.
@end menu

@c page
@node strings unsafe
@section Unsafe operations on strings


@deffn {Unsafe Operation} $string-length @var{str}
The argument @var{str} must be a string object.  Return a non--negative fixnum representing the
length of the string @var{str}.
@end deffn

@c page
@node parameters
@chapter Parameter functions and syntaxes


The library @library{mmck lang} reexports from @library{chicken base} some syntactic bindings
forming the parameters @api{}, @ChickenCoreRef{base parms, Parameters}.


@deffn Syntax parameterize ((@qvar{param} @qvar{param-expr}) @dots{}) @qvaro{expr} @qvar{expr} @dots{}
@deffnx Syntax parameterise ((@qvar{param} @qvar{param-expr}) @dots{}) @qvaro{expr} @qvar{expr} @dots{}
The syntactic binding @syntax{parameterize} is reexported from @library{chicken base}.  The
syntactic binding @syntax{parameterise} is an alias for @syntax{parameterize}.
@end deffn


@defun make-parameter @var{obj}
@defunx make-parameter @var{obj} @var{guard}
Build a new parameter.  It is reexported from @library{chicken base}.
@end defun

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
@chicken{} can be downloaded from:

@center @url{http://www.call-cc.org/}

@noindent
the package @mmck{} Lang is available from:

@center @url{https://github.com/marcomaggi/mmck-lang/}

@noindent
the package @mmck{} Checks is available from:

@center @url{https://github.com/marcomaggi/mmck-checks/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function

@printindex fn

@node variable index
@appendix An entry for each variable

@printindex vr

@node type index
@appendix An entry for each type

@printindex tp

@contents
@bye

@c end of file
@c Local Variables:
@c ispell-local-dictionary: "en_GB-ise-w_accents"
@c end:
